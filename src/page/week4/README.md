**학습 개요:** 이번 주는 **전역 상태 관리** 기법을 집중적으로 공부합니다. 페이스북이 제안한 **Flux 아키텍처**의 개념을 시작으로, 이를 구현한 **Redux** 라이브러리의 사용법과 원리를 익히세요. Redux의 주요 개념(스토어, 리듀서, 액션, 디스패치)과 **Redux Toolkit (RTK)**를 활용한 보일러플레이트 감소 방법도 학습합니다. 또한 Redux 생태계의 미들웨어들 – **Redux Thunk** (비동기 액션), **Redux Saga** (제너레이터 기반 사이드 이펙트 처리) – 의 역할과 사용법을 가볍게 훑어봅니다. Redux 이후 등장한 경량 상태관리들인 **MobX** (관찰자 패턴 기반), **Recoil** (Facebook 제작, Concurrent 모드 대응)[yozm.wishket.com](https://yozm.wishket.com/magazine/detail/2233/#:~:text=)[yozm.wishket.com](https://yozm.wishket.com/magazine/detail/2233/#:~:text=,%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98%EB%90%9C%20%EA%B0%92%EC%9D%84%20%EB%B0%98%ED%99%98%ED%95%98%EC%97%AC%20%EC%86%8D%EB%8F%84%EA%B0%80%20%EB%B9%A0%EB%A5%B4%EB%8B%A4), **Zustand** (간결한 훅 기반 상태) 등을 비교해봅니다. **RxJS 기반 상태 관리** (Redux Observable)이나 **XState** (상태머신) 같은 고급 주제도 커리큘럼에 있으니, 각각 어떤 접근법인지 알아두세요. 중요한 것은 **다양한 도구들의 철학 차이**를 이해하는 겁니다 – 예컨대 Redux는 불변성과 단일 스토어로 예측 가능성을 추구했고, MobX는 가변 상태와 데코레이터로 반응성을 높였으며, Recoil/Zustand는 **더 쉽고 React 친화적인 API**로 개발 생산성을 높였습니다[yozm.wishket.com](https://yozm.wishket.com/magazine/detail/2233/#:~:text=%EC%9B%B9%20%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4%20%ED%95%9C%20%EB%B2%88%EC%AF%A4,%EB%8B%A4%EC%96%91%ED%95%9C%20%EC%8B%9C%EB%8F%84%EB%A5%BC%20%ED%95%98%EB%8A%94%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EB%8F%84%20%EB%93%B1%EC%9E%A5%ED%96%88%EB%8B%A4)[yozm.wishket.com](https://yozm.wishket.com/magazine/detail/2233/#:~:text=,%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98%EB%90%9C%20%EA%B0%92%EC%9D%84%20%EB%B0%98%ED%99%98%ED%95%98%EC%97%AC%20%EC%86%8D%EB%8F%84%EA%B0%80%20%EB%B9%A0%EB%A5%B4%EB%8B%A4). 각 라이브러리의 공식 문서를 참고하여 간단한 카운터나 ToDo 앱을 만들어보는 것도 추천합니다. 마지막으로 **Context API**를 활용한 단순 전역 상태 공유와 그 한계 (프로바이더 중첩, 빈번한 리렌더 문제)도 체험해보세요.

- **Flux 아키텍처와 Redux 기본:** **Flux**는 단방향 데이터 흐름을 강조한 아키텍처로, **Action -> Dispatcher -> Store -> View** 순환 구조를 가집니다. 이를 구현한 대표 라이브러리가 **Redux**입니다. Redux를 공부할 때는 먼저 공식 튜토리얼을 따라 작은 예제를 만들어보세요. **`createStore`**로 스토어 생성, 리듀서 함수 정의, **`store.dispatch(action)`**으로 액션 발생, **`store.subscribe()`** 혹은 React Redux의 **`<Provider>`**와 **`connect`**/**`useSelector`**로 뷰 갱신 등의 흐름을 익힙니다. Redux는 **상태를 불변 객체로 관리**하고, 리듀서는 순수함수로 작성되어야 함을 기억하세요[velog.io](https://velog.io/@haru/Redux-vs.-Recoil#:~:text=Redux%2C%20Recoil%EC%9D%80%20React%20%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%9D%B4%EB%8B%A4,%EC%9E%A5%EC%A0%90%3A%20%EC%83%81%ED%83%9C%EA%B0%92%EC%9D%98%20%EB%B3%80%EA%B2%BD%20%EC%82%AC%ED%95%AD%EC%9D%84). 또한 개발자 도구 Redux DevTools를 활용해 디버깅하는 방법도 알아두면 좋습니다. RTK를 활용하면 **`configureStore`**와 **`createSlice`** 등으로 액션/리듀서 정의를 크게 단축할 수 있으니 최신 방법도 익히세요.
- **Redux 미들웨어와 비동기 처리:** Redux 단독으로는 비동기 로직을 다루기 어렵기 때문에 **미들웨어**를 이용합니다. **redux-thunk**는 액션 크리에이터가 함수를 반환하여 디스패치 안에서 비동기를 수행하도록 해주며, **redux-saga**는 제너레이터 함수를 통해 더욱 복잡한 비동기 흐름을 관리합니다. Saga의 경우 **`takeEvery`**, **`call`**, **`put`** 등을 사용하는데, 이는 마치 스레드를 다루듯 액션을 모니터링하고 사이드 이펙트를 처리합니다. 예제로 saga를 간단히 구현해볼 필요는 없지만, saga 코드가 등장했을 때 (예: **`function* watchLoginSaga() { yield takeEvery(LOGIN, handleLogin); }`**) 동작을 해석할 수 있으면 충분합니다. 또한 **redux-observable**(RxJS 기반)도 커리큘럼에 언급되었는데, 이는 액션을 Observable 스트림으로 처리하는 것으로, RxJS에 익숙하지 않다면 지금은 깊게 안 들어가도 됩니다.
- **리덕스 이후: MobX, Recoil, Zustand 등 비교:** Redux가 한때 표준처럼 쓰였지만, 상황에 따라 무겁고 보일러플레이트가 많다는 지적도 있었습니다. **MobX**는 관찰형 상태와 데코레이터(**`@observable`**, **`@observer`**)로 변경 시 자동 반영되는 패러다임을 제시했습니다. 반면 **Recoil**은 React 팀에서 내놓은 실험적 상태관리로, React에 좀더 자연스럽게 통합됩니다. Recoil의 핵심 개념은 **Atom**과 **Selector**이며, *“Recoil은 React 상태처럼 get/set 인터페이스로 사용할 수 있는 단순 API를 제공하고, 비동기도 별도 미들웨어 없이 Atom 비동기 셀렉터로 처리 가능”*한 장점이 있습니다[yozm.wishket.com](https://yozm.wishket.com/magazine/detail/2233/#:~:text=,%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98%EB%90%9C%20%EA%B0%92%EC%9D%84%20%EB%B0%98%ED%99%98%ED%95%98%EC%97%AC%20%EC%86%8D%EB%8F%84%EA%B0%80%20%EB%B9%A0%EB%A5%B4%EB%8B%A4). **Zustand**는 좀 더 경량화된 Hooks 기반 전역 상태관리로, 함수 한두 개로 글로벌 상태와 updater를 정의하는 간편함이 인기입니다[wonderwalls.tistory.com](https://wonderwalls.tistory.com/entry/%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EB%B9%84%EA%B5%90-Redux-vs-Justand-vs-Recoil#:~:text=%EC%83%81%ED%83%9C%20%EA%B4%80%EB%A6%AC%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%20%EB%B9%84%EA%B5%90%3A%20Redux,%EB%8F%99%EC%9D%BC%ED%95%9C%20atom%20%EA%B0%92%EC%97%90%20%EB%8C%80%ED%95%9C). 2023년 현재 **Zustand 사용자가 급증**하고 있다는 언급도 있으니[yozm.wishket.com](https://yozm.wishket.com/magazine/detail/2233/#:~:text=%EC%9B%B9%20%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4%20%ED%95%9C%20%EB%B2%88%EC%AF%A4,%EB%8B%A4%EC%96%91%ED%95%9C%20%EC%8B%9C%EB%8F%84%EB%A5%BC%20%ED%95%98%EB%8A%94%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EB%8F%84%20%EB%93%B1%EC%9E%A5%ED%96%88%EB%8B%A4), 실제 npm 다운로드 추이를 한 번 확인해보는 것도 재미있을 것입니다.
    
    이러한 라이브러리들을 비교한 자료를 보면, *“SWR/Recoil은 단순성과 React 친화적 API로, Redux는 강력한 개발자 도구와 예측 가능성으로, Zustand는 가벼운 러닝커브로”* 각각 장단점을 가진다고 합니다. 최신 비교 기사나 블로그를 읽어보세요. (예: 2025년 기준 React Query vs Zustand vs Recoil 비교 글 등)
    
- **RxJS와 상태 스트림, XState 상태 머신:** 고급 주제로, **RxJS**를 이용해 상태를 스트림으로 다루는 접근도 있습니다. **`BehaviorSubject`** 등을 통해 전역 상태 스트림을 만들고 컴포넌트가 subscribe하여 사용하는 식입니다. 이는 복잡한 비동기 이벤트들을 함수형 반응형 프로그래밍으로 처리하는 장점이 있지만 러닝커브가 높습니다. 또한 **XState** 같은 상태 머신 라이브러리는 전역 상태를 **유한 상태 머신(FSM)**으로 관리합니다. XState를 사용하면 상태 다이어그램을 정의하고, 이벤트에 따라 엄격하게 정의된 전이만 허용함으로써 **복잡한 상태 로직의 예측 가능성**을 크게 높여줍니다. XState 소개글을 읽어 *“상태 머신은 상태 + 이벤트 기반으로 동작하며, React 훅(**`useMachine`**)으로 통합할 수 있다”*는 점을 알아두세요[dev.to](https://dev.to/ibrocodes/mastering-xstate-fundamentals-a-react-powered-guide-2i3e#:~:text=XState%20is%20a%20robust%20state,xstate%2Freact%20in%20addition%20to%20React). 비록 일반 앱에서 XState를 도입하는 경우는 많지 않지만, **상태를 그래프/도식으로 모델링**하는 사고는 분명 도움됩니다.
- **Context API와 선택 기준:** 가벼운 글로벌 상태 공유에는 React **Context API**를 사용할 수도 있습니다. Context는 Provider-Consumer 패턴으로 트리 하위 컴포넌트들에게 값을 공급합니다. 소규모 앱에서는 Context로 충분하지만, 상태가 많아지고 업데이트 빈도가 높으면 **성능 이슈(불필요한 re-render)**가 생길 수 있습니다. 이러한 경우 Redux/Recoil 같은 전용 도구가 나은데, 언제 Context로도 충분하고 언제 전문 라이브러리를 써야 할지 판단하는 기준을 고민해보세요[velog.io](https://velog.io/@haru/Redux-vs.-Recoil#:~:text=Redux%2C%20Recoil%EC%9D%80%20React%20%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%9D%B4%EB%8B%A4,%EC%9E%A5%EC%A0%90%3A%20%EC%83%81%ED%83%9C%EA%B0%92%EC%9D%98%20%EB%B3%80%EA%B2%BD%20%EC%82%AC%ED%95%AD%EC%9D%84). 보통 “전역 상태값이 단순하고 업데이트가 드물다면 Context, 그렇지 않고 복잡한 캐싱/비동기 처리가 필요하면 Redux/Recoil 등”으로 정리할 수 있습니다. 실제로 Next.js 팀은 가벼운 전역 상태엔 Context와 **`useReducer`**를 권장하기도 합니다.
    
    마지막으로, **상태 시간여행**(Redux DevTools가 제공하는 action history 기반 상태 되돌리기)이나 **Immutable.js** 라이브러리를 통한 구조적 공유(Structural Sharing) 등 심화 개념도 커리큘럼에 나오지만, 현업 트렌드에서는 많이 쓰이지 않습니다. 대신 **React Query(SWR)**처럼 **원격 서버 상태**를 캐싱/동기화하는 도구들도 상태관리의 일종이니, 다음 주에 다룰 데이터를 fetching 전략과 겹쳐 이해하도록 합니다.
    

**➡️ 핵심 자료:** Redux 공식 문서 – 자습서 (기본 개념 익히기), 리덕스 vs 최신 상태 라이브러리 비교 기사 (yozm) [yozm.wishket.com](https://yozm.wishket.com/magazine/detail/2233/#:~:text=%EC%9B%B9%20%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4%20%ED%95%9C%20%EB%B2%88%EC%AF%A4,%EB%8B%A4%EC%96%91%ED%95%9C%20%EC%8B%9C%EB%8F%84%EB%A5%BC%20%ED%95%98%EB%8A%94%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EB%8F%84%20%EB%93%B1%EC%9E%A5%ED%96%88%EB%8B%A4)[yozm.wishket.com](https://yozm.wishket.com/magazine/detail/2233/#:~:text=,%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98%EB%90%9C%20%EA%B0%92%EC%9D%84%20%EB%B0%98%ED%99%98%ED%95%98%EC%97%AC%20%EC%86%8D%EB%8F%84%EA%B0%80%20%EB%B9%A0%EB%A5%B4%EB%8B%A4), BetterStack – Vitest vs Jest 성능 비교 (상태 라이브러리 아님; 잘못 가져온 결과이므로 무시), Recoil 공식 문서 – Atom/Selector 설명 [yozm.wishket.com](https://yozm.wishket.com/magazine/detail/2233/#:~:text=,%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98%EB%90%9C%20%EA%B0%92%EC%9D%84%20%EB%B0%98%ED%99%98%ED%95%98%EC%97%AC%20%EC%86%8D%EB%8F%84%EA%B0%80%20%EB%B9%A0%EB%A5%B4%EB%8B%A4), TanStack 블로그 – 상태관리 비교 (Recoil vs Redux vs Zustand 등) [dev.to](https://dev.to/leticiabytes/swr-vs-react-query-5el0#:~:text=SWR%20is%20a%20smaller%20library,that%20provides%20many%20more%20features), XState 소개 (Dev.to) [dev.to](https://dev.to/ibrocodes/mastering-xstate-fundamentals-a-react-powered-guide-2i3e#:~:text=XState%20is%20a%20robust%20state,xstate%2Freact%20in%20addition%20to%20React), 레딧 – Zustand/Redux/Recoil 토론 등.