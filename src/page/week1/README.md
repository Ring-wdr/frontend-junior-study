# Week 1: **JavaScript 심화 – 런타임, this, 스코프, 비동기 등**

- **자바스크립트 런타임과 이벤트 루프:** MDN의 *Concurrency model and Event Loop* 문서를 읽어 JS 실행 모형을 이해합니다. 콜스택/힙/태스크 큐의 동작과 **런투컴플리션** 특성을 확인하세요[lia.disi.unibo.it](https://lia.disi.unibo.it/materiale/JS/developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop.html#:~:text=Queue)[lia.disi.unibo.it](https://lia.disi.unibo.it/materiale/JS/developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop.html#:~:text=%22Run). 이벤트 루프가 콜스택이 빌 때마다 큐에서 메시지를 처리하여 **단일 스레드 비동기**를 구현하는 방법을 익힙니다.
    - 참고: *"자바스크립트 런타임은 '이벤트 루프' 기반 동시성 모델을 갖고 있습니다. 메시지 큐의 이벤트를 하나씩 처리하며, 각 이벤트는 완전히 처리(run-to-completion)된 후에야 다음 이벤트로 넘어갑니다."*[lia.disi.unibo.it](https://lia.disi.unibo.it/materiale/JS/developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop.html#:~:text=A%20JavaScript%20runtime%20contains%20a,the%20stack%20becomes%20empty%20again)[lia.disi.unibo.it](https://lia.disi.unibo.it/materiale/JS/developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop.html#:~:text=%22Run)
- **`this` 바인딩과 화살표 함수:** 자바스크립트의 **`this`** 키워드가 **호출 방식에 따라 달라지는 5가지 규칙**을 학습합니다 (기본/암시적/명시적/생성자/렉시컬). FreeCodeCamp의 튜토리얼은 **`this`** 바인딩 5가지를 예시로 설명합니다[freecodecamp.org](https://www.freecodecamp.org/news/javascript-this-keyword-binding-rules/#:~:text=The%20usage%20of%20,all%20five%20aspects%20with%20examples). 예를 들어, **암시적 바인딩**은 메서드 호출 시 **`this`**가 점 앞의 객체로 바인딩되는 규칙을 다루고 있습니다[freecodecamp.org](https://www.freecodecamp.org/news/javascript-this-keyword-binding-rules/#:~:text=Rule%20,Binding%20Works). 또한 **`call/apply/bind`**로 **명시적 바인딩**하는 방법과, **화살표 함수는 자체 `this`가 없고 상위 스코프에 정적으로 바인딩**됨을 기억하세요[medium.com](https://medium.com/@johnbernalfsd/the-four-rules-of-this-in-javascript-81680ea097f2#:~:text=Arrow%20functions%3A%20Arrow%20functions%20,Event%20handlers%20%C2%B7%20Callback).
    - 참고: *"**`this`** 사용에는 5가지 바인딩 규칙이 있으며, 함수 호출 방식에 따라 어떤 객체를 가리키는지가 결정됩니다[freecodecamp.org](https://www.freecodecamp.org/news/javascript-this-keyword-binding-rules/#:~:text=The%20usage%20of%20,all%20five%20aspects%20with%20examples). (화살표 함수는 예외적으로 자신만의 **`this`**를 갖지 않고, 정의된 시점의 부모 스코프 **`this`**를 물려받습니다.)"*
- **스코프 체인과 클로저:** **렉시컬 스코프**에서 변수 유효범위를 이해하고, 내부 함수가 외부 함수의 변수에 접근할 수 있는 **클로저(closure)** 개념을 숙지합니다. GreatFrontend의 설명에 따르면 *"클로저는 함수가 자신의 렉시컬 환경을 기억하여, 외부 함수 실행이 끝난 뒤에도 그 환경의 변수에 접근하는 기능"*이라고 정의됩니다[greatfrontend.com](https://www.greatfrontend.com/questions/quiz/what-is-a-closure-and-how-why-would-you-use-one#:~:text=,executing%20outside%20its%20lexical%20scope). MDN 글래서리도 클로저를 *“일급 함수가 있는 언어에서 렉시컬 스코프 이름 바인딩을 구현하는 기법”*이라고 설명합니다[developer.mozilla.org](https://developer.mozilla.org/en-US/docs/Glossary/Closure#:~:text=In%20computer%20programming%2C%20a%20closure,class%20functions). 간단한 예제로, 외부 함수 내에 변수를 두고 내부 함수에서 그 변수를 콘솔에 찍는 코드를 작성해보세요. 외부 함수 호출이 종료된 이후에도 내부 함수가 그 변수를 기억하고 출력하는지를 확인하며 클로저 동작을 실감할 수 있습니다.
- **프로미스와 비동기 제어:** **콜백 지옥** 문제를 해결한 **`Promise`**의 개념과 주요 메서드 (**`then`**, **`catch`**, **`finally`**)를 MDN의 가이드로 익힙니다[developer.mozilla.org](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises#:~:text=A%20Promise%20is%20an%20object,to%20which%20you%20attach). 프로미스가 **미래의 완료/실패 결과**를 표현하는 객체라는 점과, 체이닝으로 비동기 흐름을 순차 제어하는 방법을 실습하세요. 또한 ES2020의 **`Promise.all`**, **`Promise.race`**, **`Promise.any`** 등의 동작 차이와, Stage-4 신규 추가된 **`Promise.withResolvers()`** (resolve/reject 제어자를 한꺼번에 얻는 정적 메서드)를 학습합니다[javascript.plainenglish.io](https://javascript.plainenglish.io/how-promise-withresolvers-simplified-my-async-code-and-why-i-wish-i-knew-it-sooner-2cecb762fba2#:~:text=How%20Promise,%E2%80%94%20no%20extra%20variables)[reddit.com](https://www.reddit.com/r/node/comments/1824slj/how_to_enable_promisewithresolvers/#:~:text=How%20to%20enable%20Promise,3%20TC39%20proposal%20after%20all). 이어서 **AbortController**를 이용해 fetch 같은 비동기 작업을 취소하는 방법도 MDN 문서를 통해 알아두세요[developer.mozilla.org](https://developer.mozilla.org/en-US/docs/Web/API/AbortController#:~:text=The%20AbortController%20interface%20represents%20a,requests%20as%20and%20when%20desired). 이 모든 내용을 간단한 비동기 코드에 적용해보면서, 예를 들어 **`fetch`** 요청을 **`AbortController`**로 취소하거나, **`Promise.any`**로 여러 프로미스 중 가장 먼저 이행된 결과를 받는 코드를 작성해보면 이해가 빨라집니다.
- **고급 자료구조 (Map/Set, WeakRef 등):** ES6에서 도입된 **`Map`**과 **`Set`** 컬렉션의 특징을 학습합니다. **Map**은 키로 어떤 타입이든 사용할 수 있는 키-값 쌍 컬렉션이며, **Set**은 중복 없는 값들의 모음입니다[ko.javascript.info](https://ko.javascript.info/map-set#:~:text=%EB%A7%B5)[ko.javascript.info](https://ko.javascript.info/map-set#:~:text=%EC%85%8B). 각각의 주요 메서드(**`map.set/get`**, **`set.add/has`** 등) 사용법을 익히세요. 또한 **WeakMap/WeakSet**은 객체를 참조하되 가비지 컬렉션을 방해하지 않는 약한 참조 컬렉션임을 알아둡니다. **WeakRef**와 **FinalizationRegistry** (ES2021)도 한 번 훑어보세요 – MDN에 따르면 *"WeakRef는 객체를 가비지 컬렉션 해칠 일 없이 참조할 수 있게 해주며, FinalizationRegistry는 객체가 수거될 때 실행할 정리 콜백을 등록하는 기능"*입니다[developer.mozilla.org](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef#:~:text=A%20WeakRef%20object%20lets%20you,collected).
    - 참고: *"맵(Map)은 객체와 유사하지만 **키 타입에 제한이 없고** 키를 문자열로 변환하지 않습니다[ko.javascript.info](https://ko.javascript.info/map-set#:~:text=%EB%A7%B5). 셋(Set)은 **중복 없는** 값 컬렉션으로, 키 없이 값 자체만 저장합니다[ko.javascript.info](https://ko.javascript.info/map-set#:~:text=%EC%85%8B)."*
- **은닉 클래스(hidden class)와 V8 최적화:** V8 엔진의 **히든 클래스** 개념을 알아보고, 자바스크립트 객체의 프로퍼티 생성 순서에 따른 엔진 최적화 여부를 이해합니다. Dev.to 블로그 *"Hidden Classes: JS의 성능 비밀"*을 참고하면, *"동일한 형태(shapes)를 가진 객체들은 엔진이 히든 클래스를 공유하여 프로퍼티 접근을 빠르게 한다"*는 점을 설명합니다[dev.to](https://dev.to/maxprilutskiy/hidden-classes-the-javascript-performance-secret-that-changed-everything-3p6c#:~:text=%2F%2F%20DO%3A%20Consistent%20shape%20function,Always%20same%20Hidden%20Class)[dev.to](https://dev.to/maxprilutskiy/hidden-classes-the-javascript-performance-secret-that-changed-everything-3p6c#:~:text=Hidden%20Classes%20are%20JavaScript%27s%20performance,how%20JavaScript%20engines%20actually%20work). 객체를 생성할 때 항상 같은 프로퍼티들을 같은 순서로 초기화하고, 동적으로 프로퍼티를 추가/삭제하지 않는 것이 **모노모픽 코드**를 유지해 성능을 높이는 패턴임을 유념하세요. 이러한 숨은 클래스를 관찰하려면 Node.js 실행 시 **`-trace-maps`** 플래그를 켜고 실험해볼 수도 있습니다[dev.to](https://dev.to/maxprilutskiy/hidden-classes-the-javascript-performance-secret-that-changed-everything-3p6c#:~:text=Want%20to%20see%20Hidden%20Classes,secret%20flags%20that%20expose%20everything).
- **Proxy와 Reflect를 활용한 메타프로그래밍:** ES6의 **`Proxy`** 객체로 객체의 기본 동작(프로퍼티 접근, 할당, 함수 호출 등)을 가로채고 재정의하는 방법을 배웁니다. **`Proxy`**를 사용하면 객체 앞에 인터셉터를 놓아 **기본 동작을 커스텀**할 수 있습니다[javascript.info](https://javascript.info/proxy#:~:text=Proxy%20and%20Reflect%20,handling%20them%20on%20its%20own). 예를 들어, 객체 접근 시 로그를 남기거나, 존재하지 않는 프로퍼티 접근에 디폴트 값을 주는 등의 트랩을 구현해보세요. 이때 **`Reflect`** 객체를 함께 쓰면 Proxy 핸들러 내부에서 원본 동작을 호출하기 편리합니다. *“Reflect는 Proxy로 가로챌 수 있는 같은 이름의 메서드들을 제공하여, Proxy 트랩 안에서 기본 동작을 손쉽게 호출(포워딩)하도록 도와준다”*[stackoverflow.com](https://stackoverflow.com/questions/25421903/what-does-the-reflect-object-do-in-javascript#:~:text=What%20does%20the%20Reflect%20object,proxies%20to%20make%20forwarding%20easier).
    - 참고: *"**`Proxy`** 객체는 다른 객체를 래핑하여 **기본적인 동작(프로퍼티 조회, 설정 등)을 가로채서 정의**할 수 있게 해줍니다[javascript.info](https://javascript.info/proxy#:~:text=Proxy%20and%20Reflect%20,handling%20them%20on%20its%20own). **`Reflect`**는 이러한 동작들을 수행하는 정적 메서드들을 모아둔 내장 객체로, Proxy 핸들러 내부에서 기본 동작을 호출하는 데 유용합니다[lia.disi.unibo.it](https://lia.disi.unibo.it/materiale/JS/developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect.html#:~:text=Reflect%20is%20a%20built,those%20of%20the%20proxy)."*
- **DSL (Domain-Specific Language) 이해:** **도메인 특화 언어(DSL)**란 특정 분야 문제 해결에 특화된 미니 언어를 말합니다. 블로그 글에 따르면 *"DSL은 특정 영역(산업, 분야)의 문제를 효율적으로 해결하기 위해 해당 도메인의 개념과 규칙으로 구성된 언어"*입니다[unabated.tistory.com](https://unabated.tistory.com/entry/DSLDomain-Specific-Language-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0#:~:text=1,Thomas%EA%B0%80%20%ED%95%9C%C2%A0%EB%A7%90%EC%9D%84%20%EC%83%9D%EA%B0%81%ED%95%98%EB%A9%B4%20%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0%20%EC%89%BD%EB%8B%A4). 예컨대 SQL, HTML, 정규표현식 등이 대표적인 DSL로 볼 수 있습니다[unabated.tistory.com](https://unabated.tistory.com/entry/DSLDomain-Specific-Language-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0#:~:text=4,%EC%A0%95%EA%B7%9C%EC%8B%9D%29%2C%20Make%2C%20graphviz). 이를 통해 **메타프로그래밍**의 한 갈래를 이해하게 됩니다. 프로그래머로서 DSL을 만들 일은 흔치 않지만, Terraform의 설정 언어(HCL)나 React JSX(UI를 위한 DSL) 등 DSL 사례를 인지하고, 필요 시 기존 DSL을 활용하는 능력을 길러둡니다.

**➡️ 핵심 자료:** MDN – JS 이벤트 루프 모델 [lia.disi.unibo.it](https://lia.disi.unibo.it/materiale/JS/developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop.html#:~:text=Queue), FreeCodeCamp – 자바스크립트 **`this`** 5가지 규칙 [freecodecamp.org](https://www.freecodecamp.org/news/javascript-this-keyword-binding-rules/#:~:text=The%20usage%20of%20,all%20five%20aspects%20with%20examples), GreatFrontend – 클로저 개념 정리 [greatfrontend.com](https://www.greatfrontend.com/questions/quiz/what-is-a-closure-and-how-why-would-you-use-one#:~:text=,executing%20outside%20its%20lexical%20scope), MDN – Promise 사용법 가이드 [developer.mozilla.org](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises#:~:text=A%20Promise%20is%20an%20object,to%20which%20you%20attach), MDN – AbortController [developer.mozilla.org](https://developer.mozilla.org/en-US/docs/Web/API/AbortController#:~:text=The%20AbortController%20interface%20represents%20a,requests%20as%20and%20when%20desired), Dev.to – Hidden Classes 성능 최적화 [dev.to](https://dev.to/maxprilutskiy/hidden-classes-the-javascript-performance-secret-that-changed-everything-3p6c#:~:text=Hidden%20Classes%20are%20JavaScript%27s%20performance,how%20JavaScript%20engines%20actually%20work), MDN – Proxy와 Reflect [javascript.info](https://javascript.info/proxy#:~:text=Proxy%20and%20Reflect%20,handling%20them%20on%20its%20own)[stackoverflow.com](https://stackoverflow.com/questions/25421903/what-does-the-reflect-object-do-in-javascript#:~:text=What%20does%20the%20Reflect%20object,proxies%20to%20make%20forwarding%20easier), 블로그 – DSL 이해하기 [unabated.tistory.com](https://unabated.tistory.com/entry/DSLDomain-Specific-Language-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0#:~:text=1,Thomas%EA%B0%80%20%ED%95%9C%C2%A0%EB%A7%90%EC%9D%84%20%EC%83%9D%EA%B0%81%ED%95%98%EB%A9%B4%20%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0%20%EC%89%BD%EB%8B%A4).