# Week 2: 프로그래밍 패러다임 – 객체지향 디자인 패턴

## 학습 개요

이번 주는 **객체지향 프로그래밍(OOP)**의 철학과 다양한 **디자인 패턴**들을 배웁니다.

**순서**
1. OOP의 기본 개념(캡슐화, 상속, 다형성) 복습
2. JS에서 **프로토타입 기반 객체지향** 이해
3. **GoF의 디자인 패턴 23가지** 중 핵심 패턴 학습
4. 후반부: **함수형 프로그래밍(Functional Programming)** 시작

**핵심 목표**
> 문제 상황에 알맞은 해결 구조를 인식하는 것이 목표입니다. 암기보다는 **"이런 문제가 있을 때 쓰는 패턴이 있지!"** 하고 떠올릴 수 있도록 감을 익히세요.

---

## 객체지향 개념과 SOLID 원칙

**자바스크립트의 이중성**
- 함수형 패러다임을 기반으로 하면서 객체지향 문법을 둘러쌈
- OOP와 FP를 모두 활용 가능한 **멀티 패러다임** 언어

**OOP의 핵심 개념**
- **캡슐화**: 정보 은닉
- **상속**: 프로토타입 체인
- **다형성**: 동적 바인딩

**SOLID 원칙**
- **S** – 단일 책임 원칙
- **O** – 개방-폐쇄 원칙
- **L** – 리스코프 치환 원칙
- **I** – 인터페이스 분리 원칙
- **D** – 의존성 역전 원칙

> JS에서는 인터페이스 개념이 명시적이진 않지만, 디자인 패턴을 통해 느슨한 결합을 구현할 수 있습니다.

**학습 자료**
- Velog – Functional Programming

---

## 디자인 패턴 개괄 및 싱글톤 패턴

**디자인 패턴이란**
- 반복되는 소프트웨어 문제의 **표준 해법**
- 효율적이고 검증된 설계 방법

**싱글톤 패턴**

개념
: 애플리케이션에서 인스턴스를 단 하나만 생성해 전역적으로 공유하는 패턴

구현 방법
- 모듈 패턴
- 클래스의 정적 프로퍼티

활용 사례
- 전역 네임스페이스 오염 방지
- 전역 상태 관리

**학습 자료**
- Patterns.dev – 디자인 패턴 개괄 및 싱글톤

---

## 팩토리와 추상 팩토리 패턴

**팩토리 메서드 패턴**

의도
: 객체 생성 코드를 캡슐화하여, 상위 클래스에서 인터페이스만 정의하고 하위 클래스가 구체 클래스를 결정

구현 방법 (JavaScript)
- 생성자 함수로 구현
- 클래스의 `static` 메서드로 구현

**추상 팩토리 패턴**

의도
: 관련된 객체군을 생성하는 팩토리들을 통합

예시
: UI 컴포넌트 테마별 팩토리

---

## 구조 패턴 (어댑터, 데코레이터, 프록시 등)

**분류**
구조를 조직화하는 패턴들입니다.

**어댑터 (Adapter)**
- 역할: 인터페이스 호환을 위한 중간 변환기
- 사용 사례: 레거시 코드 통합

**데코레이터 (Decorator)**
- 역할: 객체에 기능을 덧붙이는 래퍼
- JavaScript 구현: 함수 데코레이터로 함수나 클래스에 새로운 동작 주입

**프록시 (Proxy)**
- 역할: 접근 제어나 부가기능을 위한 대리자

**퍼사드 (Facade)**
- 역할: 복잡한 하위 시스템을 간단한 인터페이스로 감싸기
- 예시: 여러 모듈의 호출을 한 함수로 통합

**브리지 (Bridge)**
- 역할: 구현과 추상을 분리하여 둘을 독립적으로 확장
- 예시: 서로 다른 구현체를 런타임에 교체 가능하도록 인터페이스 계층 추가

**실습 팁**
각 패턴 의도를 한 문장으로 설명해보고, JS에서는 어떨 때 쓸법한지 떠올려보세요.

**학습 자료**
- Rob Dodson 블로그 – JS 디자인 패턴 코드 예시

---

## 행위 패턴 (옵저버, 전략, 상태 등)

**옵저버 (Observer)**

의도
: 한 객체의 상태 변화에 따라 다른 객체들이 업데이트되는 **발행-구독** 모델

JavaScript 구현
- DOM 이벤트
- Node의 EventEmitter
- 커스텀 이벤트 시스템

**전략 (Strategy)**

의도
: 알고리즘 군을 정의하고 런타임에 교체할 수 있도록 구현

JavaScript 활용
- 함수를 인수로 전달 (콜백)
- 간단하고 직관적인 구현

**상태 (State)**

의도
: 객체의 상태에 따라 행동을 분리

복잡한 상태 전이 관리
- `state` 객체에 현재 상태별 메서드 작성
- 상태 전환 시 내부 포인터만 변경

**기타 행위 패턴**
- **커맨드 (Command)**: 요청을 객체로 캡슐화
- **템플릿 메서드 (Template Method)**: 알고리즘의 골격 정의, 상세는 서브클래스에서
- **메멘토 (Memento)**: 객체 상태 스냅샷 저장/복원
- **방문자 (Visitor)**: 객체 구조에 새로운 연산 추가
- **중재자 (Mediator)**: 객체들 간의 복잡한 통신 중앙화

**학습 전략**
- 모든 패턴을 깊이 공부하기보다 **이름과 대략적 목적 파악**에 집중
- 필요할 때 책이나 레퍼런스를 찾아 적용할 수 있으면 충분합니다

**참고**
> 디자인 패턴은 시대에 따라 사용 빈도가 변합니다. 몇몇 고전 패턴은 현대 프레임워크 등장 이후 예전만큼 쓰이지 않게 되었지만, 일부는 최신 기술에 맞게 발전했습니다.
>
> - **Redux**: 커맨드 패턴 + 옵저버 패턴의 결합
> - **React Hooks**: 옵저버 없이 상태 공유를 구현한 새로운 패러다임

**학습 자료**
- Patterns.dev – 행위 패턴 상세 설명
- Refactoring.Guru – 패턴의도 한글 설명

---

## 함수형 프로그래밍 시작하기

### 기본 개념

**함수형 프로그래밍(FP)이란**
> 외부에서 관찰 가능한 부수효과를 제거하고, **불변 데이터**와 **순수함수**로 로직을 선언적으로 구성하는 프로그래밍 방식

**핵심 특성**

1. **순수함수 (Pure Function)**
   - 동일 입력 → 항상 동일 출력
   - 부수효과 없음

2. **불변성 (Immutability)**
   - 데이터 변경 대신 새 데이터 생성
   - 기존 데이터는 유지

3. **고계함수 (Higher-Order Function)**
   - 함수를 인수나 반환값으로 사용
   - JavaScript는 함수가 일급 객체 → 충분히 활용 가능

**JavaScript와 함수형**
- React의 선언적 UI
- Redux의 불변 상태 관리
- 모두 함수형 사고에 기반

---

### OOP vs 함수형 프로그래밍

**OOP (Object-Oriented Programming)**
- 객체를 중심으로 사고

**함수형 프로그래밍 (Functional Programming)**
- **데이터를 함수로 연결**하는 것을 중심으로 사고

**보완 관계**
- 각각의 장점을 활용하는 멀티 패러다임 접근

---

### 함수형 핵심 기법

**함수 합성 (Function Composition)**
- 여러 함수를 조합해 새로운 함수 생성
- 작은 단위의 순수함수들을 조합

**커링 (Currying)**
- 다중 인수 함수를 단일 인수 함수들의 시퀀스로 변환
- 부분 적용(Partial Application) 활성화

**모나드 (Monad)**
- "컨테이너와 연산을 합성하는 디자인 패턴" 정도로 이해하고 넘어가도 됨
- 더 깊은 이해는 고급 주제

**유틸리티 라이브러리**
- **Lodash**: 편리한 함수형 유틸리티
- **Ramda**: 함수형 프로그래밍 전용 라이브러리

---

### 함수형으로 패턴 대체하기

**흥미로운 발견**
JS에서는 함수를 이용해 **디자인 패턴을 단순화**할 수 있습니다.

**예시**

싱글톤 패턴 → 즉시 실행 함수
: 클로저에 객체를 캡슐화하여 하나만 생성

```javascript
const Singleton = (() => {
  let instance;
  return {
    getInstance: () => {
      if (!instance) {
        instance = { /* ... */ };
      }
      return instance;
    }
  };
})();
```

전략 패턴 → 함수 인자
: 함수를 인자로 받아 실행하는 것으로 쉽게 구현

```javascript
const applyStrategy = (data, strategy) => strategy(data);
```

**프레임워크의 진화**
- FP 스타일이 때론 패턴 구현을 단순화
- 프레임워크가 패턴을 내장하여 개발자가 직접 구현할 필요를 줄이는 추세

**React Hooks의 사례**
- 컨테이너/프레젠테이셔널 패턴 대체
- Context API + custom hook으로 Container 컴포넌트 없이 관심사 분리 가능
- "패턴이 언어나 프레임워크에 내장되는 경향"을 이해하게 됨

**학습 자료**
- Velog – 함수형 프로그래밍 다시 보기
- wormwlrm 블로그 – 함수형 자바스크립트 책 후기

---

## 핵심 자료

- [Patterns.dev 한국어 – 디자인 패턴 소개 및 목록](https://patterns-dev-kr.github.io/design-patterns/introduction/)
- [Patterns.dev – Singleton 패턴 예제](https://patterns-dev-kr.github.io/design-patterns/singleton-pattern/)
- [Rob Dodson 블로그 – JS 싱글톤 패턴 코드 예시](https://robdodson.me/posts/javascript-design-patterns-singleton/)
- [Addy Osmani eBook – JavaScript Design Patterns (무료)](https://www.patterns.dev/posts/classic-design-patterns/)
- [Velog – 함수형 프로그래밍 다시 보기](https://velog.io/@teo/functional-programming)
- [wormwlrm 블로그 – 함수형 자바스크립트 책 후기](https://wormwlrm.github.io/2022/03/08/Functional-Programming-in-JavaScript.html)
- [Refactoring.Guru – 디자인 패턴 카탈로그](https://refactoring.guru/design-patterns)
