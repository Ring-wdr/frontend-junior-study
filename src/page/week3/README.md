# Week 3: **프론트엔드 디자인 패턴 – 컴포넌트 아키텍처**

**학습 개요:** 이번 주는 **React 등 프론트엔드에 특화된 설계 패턴**을 다룹니다. UI 구성 및 상태관리 측면에서 나온 패턴들을 익혀보세요. 먼저 **Atomic Design** 방법론으로 디자인 시스템 구축하는 법을 알아봅니다. 그 다음 **Presentational vs Container 컴포넌트 패턴**으로 관심사 분리를 구현하는 고전적인 React 패턴을 살펴봅니다[patterns-dev-kr.github.io](https://patterns-dev-kr.github.io/design-patterns/container-presentational-pattern/#:~:text=%EC%9D%B4%EC%83%81%EC%A0%81%EC%9C%BC%EB%A1%9C%EB%8A%94%20%EC%9D%B4%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC%20%EC%95%84%EB%9E%98%20%EB%91%90%EA%B0%80%EC%A7%80%EB%A1%9C,%EB%B6%84%EB%A6%AC%ED%95%98%EC%97%AC%20%EA%B4%80%EC%8B%AC%EC%82%AC%EC%9D%98%20%EB%B6%84%EB%A6%AC%EB%A5%BC%20%EA%B0%95%EC%A0%9C%ED%95%98%EA%B3%A0%20%EC%8B%B6%EB%8B%A4). 최근에는 이를 **커스텀 훅(Hooks)**으로 대체하는 추세도 함께 알아두세요[patterns-dev-kr.github.io](https://patterns-dev-kr.github.io/design-patterns/container-presentational-pattern/#:~:text=Hooks). **Compound Components** 패턴 (Context를 이용해 관련된 컴포넌트들이 서로 조합되도록), **Render Props** 패턴과 **Higher-Order Components (HOC)** 패턴 (둘 다 컴포넌트 로직 재사용을 위한 옛 기법)을 학습하고, 이러한 패턴들이 React 훅 등장 이전에 쓰이다가 지금은 훅으로 많이 대체되었음을 이해합니다. 또한 **가상화(Virtualization)**, **메모이제이션(Memoization)** 등의 성능 패턴도 학습합니다. 이 주의 학습은 실습으로 이어지기 좋습니다 – Storybook으로 Atomic Design 연습을 해보거나, 간단한 Presentational/Container 구조로 앱을 나눠보세요.

- **Atomic Design으로 디자인 시스템 구축:** Atomic Design은 Brad Frost가 제안한 **컴포넌트 기반 디자인** 방법론입니다. UI 컴포넌트를 **원자(Atoms)**, **분자(Molecules)**, **유기체(Organisms)**, **템플릿(Templates)**, **페이지(Pages)**의 5단계로 분류하여 일관된 디자인 시스템을 만드는 것이 핵심입니다[ghost4551.tistory.com](https://ghost4551.tistory.com/255#:~:text=%EC%9B%B9%20%ED%94%84%EB%A1%A0%ED%8A%B8%20%EA%B0%9C%EB%B0%9C%20%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%2C%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%9D%B8,React%EB%8A%94%20%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%20%EB%8B%A8%EC%9C%84%EB%A1%9C%20%EA%B0%9C%EB%B0%9C%EC%9D%84%20%EC%A7%84%ED%96%89%ED%95%9C%EB%8B%A4)[ghost4551.tistory.com](https://ghost4551.tistory.com/255#:~:text=%EC%95%84%ED%86%A0%EB%AF%B9%20%EB%94%94%EC%9E%90%EC%9D%B8%EC%9D%80%20%EC%9B%90%EC%9E%90,Pages%29%EB%A1%9C%20%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9D%B8%20%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%84%20%EB%A7%8C%EB%93%A0%EB%8B%A4). 예를 들어, 버튼이나 아이콘은 원자, 검색 폼은 분자, 헤더+네비게이션은 유기체, 전체 레이아웃이 템플릿, 실제 콘텐츠 채운 완성 화면이 페이지가 됩니다. 아토믹 디자인 개념을 정리한 블로그를 읽고[ghost4551.tistory.com](https://ghost4551.tistory.com/255#:~:text=%EC%9B%B9%20%ED%94%84%EB%A1%A0%ED%8A%B8%20%EA%B0%9C%EB%B0%9C%20%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%2C%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%9D%B8,React%EB%8A%94%20%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%20%EB%8B%A8%EC%9C%84%EB%A1%9C%20%EA%B0%9C%EB%B0%9C%EC%9D%84%20%EC%A7%84%ED%96%89%ED%95%9C%EB%8B%A4), 본인만의 UI 컴포넌트를 위 계층 구조로 분류해보세요. Storybook을 사용한다면 Atoms 단위부터 컴포넌트를 구현하고 조합해나가는 연습을 할 수 있습니다. 이 패턴을 따르면 컴포넌트 재사용성과 일관성이 크게 높아지며, 대규모 디자인 시스템에서 특히 유용합니다.
- **Presentational vs Container 패턴:** 이는 **UI 담당 컴포넌트**와 **데이터/로직 담당 컴포넌트**를 분리하는 React 설계 패턴입니다[patterns-dev-kr.github.io](https://patterns-dev-kr.github.io/design-patterns/container-presentational-pattern/#:~:text=%EC%9D%B4%EC%83%81%EC%A0%81%EC%9C%BC%EB%A1%9C%EB%8A%94%20%EC%9D%B4%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC%20%EC%95%84%EB%9E%98%20%EB%91%90%EA%B0%80%EC%A7%80%EB%A1%9C,%EB%B6%84%EB%A6%AC%ED%95%98%EC%97%AC%20%EA%B4%80%EC%8B%AC%EC%82%AC%EC%9D%98%20%EB%B6%84%EB%A6%AC%EB%A5%BC%20%EA%B0%95%EC%A0%9C%ED%95%98%EA%B3%A0%20%EC%8B%B6%EB%8B%A4). Presentational 컴포넌트는 props로 전달된 데이터를 **어떻게 보여줄지(render)**만 신경쓰고, Container 컴포넌트는 어떤 데이터를 가져와서 어떤 Presentational에게 넘길지 관리합니다[patterns-dev-kr.github.io](https://patterns-dev-kr.github.io/design-patterns/container-presentational-pattern/#:~:text=1,%EC%98%88%EC%A0%9C%EC%97%90%EC%84%9C%EB%8A%94%20%EA%B0%95%EC%95%84%EC%A7%80%20%EC%82%AC%EC%A7%84%EB%93%A4%EC%9D%84%20%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C%ED%95%9C%EB%8B%A4)[patterns-dev-kr.github.io](https://patterns-dev-kr.github.io/design-patterns/container-presentational-pattern/#:~:text=Presentational%20Component). 과거 Redux 사용 시 **Container 컴포넌트**가 **`connect()`**로 store에서 state를 받고 **Presentational 컴포넌트**에 넘겨주는 형태로 많이 쓰였습니다. 이 패턴을 연습하려면, 예를 들어 강아지 사진 API를 불러와 목록을 보여주는 앱을 두 컴포넌트로 나눠보세요. **`<DogImagesContainer>`**에서 **`fetch`**로 이미지를 받아 state로 관리하고, **`<DogImages>`** Presentational 컴포넌트에 props로 전달해 이미지 리스트를 렌더링합니다[patterns-dev-kr.github.io](https://patterns-dev-kr.github.io/design-patterns/container-presentational-pattern/#:~:text=%EC%97%AC%EA%B8%B0%EC%84%9C%20,Presentational%20%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90%20%EC%9D%98%ED%95%B4%20%EC%88%98%EC%A0%95%EB%90%98%EC%A7%80%20%EC%95%8A%EB%8A%94%EB%8B%A4)[patterns-dev-kr.github.io](https://patterns-dev-kr.github.io/design-patterns/container-presentational-pattern/#:~:text=Container%20%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98%20%EC%A3%BC%EC%9A%94%20%EA%B8%B0%EB%8A%A5%EC%9D%80%20Presentational,%EA%B7%B8%EB%A6%AC%EC%A7%80%20%EC%95%8A%EC%9C%BC%EB%8B%88%20%EC%8A%A4%ED%83%80%EC%9D%BC%EC%8B%9C%ED%8A%B8%EB%8F%84%20%ED%8F%AC%ED%95%A8%ED%95%98%EC%A7%80%20%EC%95%8A%EB%8A%94%EB%8B%A4). 이렇게 하면 **비즈니스 로직**과 **뷰 로직**이 깔끔히 분리됩니다.
    - 현대 React에서는 이 패턴이 **Hooks**로 많이 대체되었습니다[patterns-dev-kr.github.io](https://patterns-dev-kr.github.io/design-patterns/container-presentational-pattern/#:~:text=Hooks). 위 예시도 **`useDogImages`**라는 커스텀 훅을 만들어 **`DogImages`** 내부에서 호출하면, 굳이 Container 컴포넌트 계층이 없어도 동일한 효과를 얻습니다[patterns-dev-kr.github.io](https://patterns-dev-kr.github.io/design-patterns/container-presentational-pattern/#:~:text=%EB%8C%80%EA%B0%9C%20Container%2FPresentational%20%ED%8C%A8%ED%84%B4%EC%9D%80%20React%20Hooks%EB%A1%9C,%EC%89%BD%EA%B2%8C%20%EB%A7%8C%EB%93%A4%20%EC%88%98%20%EC%9E%88%EA%B2%8C%20%EB%90%98%EC%97%88%EB%8B%A4)[patterns-dev-kr.github.io](https://patterns-dev-kr.github.io/design-patterns/container-presentational-pattern/#:~:text=%EC%9C%84%EC%9D%98%20%ED%9B%85%EC%9D%84%20%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC%20%EB%B0%9B%EC%95%84%EC%98%A4%EA%B8%B0,%ED%9B%85%EC%9D%84%20%EC%A7%81%EC%A0%91%20%ED%98%B8%EC%B6%9C%ED%95%B4%20%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4%20%EB%90%9C%EB%8B%A4). 따라서 Hooks의 등장으로 HOC/Render Props/Container 등의 패턴 사용이 줄어들었음을 알아두세요.
- **Compound Components 패턴:** Compound Components는 **여러 하위 컴포넌트가 하나의 단위처럼 협력**하도록 만드는 패턴입니다. React의 **`<Tabs>`** 컴포넌트를 떠올리면, **`<Tabs>`** 안에 **`<Tab>`**들, **`<TabPanels>`** 안에 **`<TabPanel>`**들이 들어가며, 각각 Context로 연결되어 동작하는 식입니다. 이 패턴은 보통 **Context API**나 **React.Children**을 사용해 구현합니다. 예를 들어 **`<Dropdown>`** 컴포넌트를 만들고 그 안에 **`<Dropdown.Item>`**들을 정의하여 Dropdown 컴포넌트가 열리고 닫히는 상태를 Context로 제공하면, Item들은 Context의 상태에 따라 자기 표시를 제어할 수 있습니다. 이 패턴을 통해 사용자에게는 마치 **`<Dropdown>`** 하나의 컴포넌트처럼 보이지만 내부적으로 역할이 분담된 컴포넌트를 제공할 수 있습니다. Compound Components 패턴은 Patterns.dev 한국어 문서의 **Compound 패턴** 장에서도 확인할 수 있습니다[patterns-dev-kr.github.io](https://patterns-dev-kr.github.io/design-patterns/singleton-pattern/#:~:text=,18)[patterns-dev-kr.github.io](https://patterns-dev-kr.github.io/design-patterns/singleton-pattern/#:~:text=,19).
- **Render Props 패턴:** Render Props는 컴포넌트 간 **공유 로직을 전달**하는 오래된 기법으로, prop으로 함수를 전달해 해당 함수를 호출하여 UI를 결정하는 방식입니다. 예를 들어 **`<DataFetcher render={data => <Profile info={data}/>} />`** 형태로 **`DataFetcher`** 컴포넌트가 데이터를 가져온 후 **`render`** prop 함수로 UI를 그려주는 식입니다. 이를 통해 DataFetcher는 UI를 몰라도 되고, 호출자는 데이터 가져오기 로직을 신경쓰지 않는 **관심사 분리**가 가능합니다. 하지만 JSX 중첩이 복잡해지고, Hooks 등장 이후 잘 쓰지 않게 되었습니다.
- **Higher-Order Components (HOC):** HOC는 *“컴포넌트를 인수로 받아 새로운 컴포넌트를 반환하는 함수”*입니다. 예컨대 **`withAuth(UserComponent)`**라는 HOC가 있다면, **`UserComponent`**에 인증 여부 체크 로직을 주입한 새로운 컴포넌트를 반환합니다. Redux의 **`connect(mapStateToProps)`** 함수가典형적인 HOC였습니다. HOC의 장점은 로직 재사용이지만, Prop 이름 충돌이나 컴포넌트 트리 추적 어려움 등의 단점(**`Wrapper Hell`**) 때문에 요즘은 잘 사용하지 않습니다. 그래도 패턴 자체는 알아두고, 만약 HOC로 작성된 오래된 코드를 만나도 이해할 수 있도록 합니다. Patterns.dev 한국어 문서에서도 **HOC 패턴**을 다루고 있으니 참고하세요[patterns-dev-kr.github.io](https://patterns-dev-kr.github.io/design-patterns/container-presentational-pattern/#:~:text=,13).
- **기타 패턴 – Memoization, Virtualization:** **메모이제이션**은 비싼 연산 결과를 캐시하여 동일 입력 시 함수를 재실행하지 않는 최적화 기법입니다. React에서는 **`React.memo`**나 **`useMemo`** Hook으로 컴포넌트 결과나 연산을 메모이제이션합니다. 이 패턴을 통해 불필요한 재연산/재렌더링을 줄여 성능을 높이는 법을 실습해보세요 (예: 아주 큰 리스트를 정렬하는 함수에 **`useMemo`** 적용 등). **리스트 가상화(Virtualization)**는 화면에 보이는 목록 아이템만 렌더링하고 나머지는 렌더링하지 않음으로써 대량의 DOM 처리를 최적화하는 기법입니다. **`react-window`**나 **`react-virtualized`** 라이브러리를 사용하면 쉽게 구현 가능합니다. 가능하다면 수천 개 아이템을 스크롤하는 리스트를 가상화 전후로 만들어 성능 차이를 관찰해보세요. 마지막으로, **Lifted State**(여러 컴포넌트에서 공유되는 상태를 공통 조상으로 끌어올려 관리)나 **State Reducer 패턴**(컴포넌트 내부 state 업데이트 로직을 외부에서 제어할 수 있게 하는 패턴) 같은 것도 언급되지만, 우선순위는 낮으므로 필요한 경우 자료를 찾아보는 수준으로 두어도 괜찮습니다.

**➡️ 핵심 자료:** Atomic Design 소개 블로그 [ghost4551.tistory.com](https://ghost4551.tistory.com/255#:~:text=%EC%9B%B9%20%ED%94%84%EB%A1%A0%ED%8A%B8%20%EA%B0%9C%EB%B0%9C%20%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%2C%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%9D%B8,React%EB%8A%94%20%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%20%EB%8B%A8%EC%9C%84%EB%A1%9C%20%EA%B0%9C%EB%B0%9C%EC%9D%84%20%EC%A7%84%ED%96%89%ED%95%9C%EB%8B%A4), Patterns.dev – Container/Presentational 패턴 [patterns-dev-kr.github.io](https://patterns-dev-kr.github.io/design-patterns/container-presentational-pattern/#:~:text=%EC%9D%B4%EC%83%81%EC%A0%81%EC%9C%BC%EB%A1%9C%EB%8A%94%20%EC%9D%B4%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC%20%EC%95%84%EB%9E%98%20%EB%91%90%EA%B0%80%EC%A7%80%EB%A1%9C,%EB%B6%84%EB%A6%AC%ED%95%98%EC%97%AC%20%EA%B4%80%EC%8B%AC%EC%82%AC%EC%9D%98%20%EB%B6%84%EB%A6%AC%EB%A5%BC%20%EA%B0%95%EC%A0%9C%ED%95%98%EA%B3%A0%20%EC%8B%B6%EB%8B%A4)[patterns-dev-kr.github.io](https://patterns-dev-kr.github.io/design-patterns/container-presentational-pattern/#:~:text=Container%20%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98%20%EC%A3%BC%EC%9A%94%20%EA%B8%B0%EB%8A%A5%EC%9D%80%20Presentational,%EA%B7%B8%EB%A6%AC%EC%A7%80%20%EC%95%8A%EC%9C%BC%EB%8B%88%20%EC%8A%A4%ED%83%80%EC%9D%BC%EC%8B%9C%ED%8A%B8%EB%8F%84%20%ED%8F%AC%ED%95%A8%ED%95%98%EC%A7%80%20%EC%95%8A%EB%8A%94%EB%8B%A4), Patterns.dev – Hooks 패턴 (Container 패턴 대체 예시)[patterns-dev-kr.github.io](https://patterns-dev-kr.github.io/design-patterns/container-presentational-pattern/#:~:text=Hooks), Patterns.dev – Compound 패턴 [patterns-dev-kr.github.io](https://patterns-dev-kr.github.io/design-patterns/singleton-pattern/#:~:text=,Learning%20JavaScript%20Design%20Patterns), Patterns.dev – HOC 패턴 [patterns-dev-kr.github.io](https://patterns-dev-kr.github.io/design-patterns/container-presentational-pattern/#:~:text=,13), UI 개발 패턴 총정리 블로그 (패턴 비교), Kent C. Dodds – React Patterns (참고 자료).