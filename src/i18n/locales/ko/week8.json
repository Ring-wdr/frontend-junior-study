{
  "header": {
    "title": "Frontend Testing",
    "description": "Unit, Integration, E2E Testing: 처음부터 종합적인 테스팅 전략을 구축합니다."
  },
  "tabs": {
    "all": "전체",
    "fundamentals": "기초",
    "unit": "Unit Testing",
    "integration": "Integration",
    "vitest": "Vitest",
    "e2e": "E2E",
    "bestPractices": "Best Practices"
  },
  "fundamentals": {
    "badge": "Testing Pyramid",
    "title": "Testing Fundamentals",
    "description": "세 가지 레벨의 테스팅과 그것이 왜 중요한지 이해합니다.",
    "pyramid": {
      "title": "The Testing Pyramid",
      "description": "테스팅 피라미드는 다양한 테스트 유형 간의 관계를 보여줍니다. 더 많은 unit test를 작성하고, 적당한 양의 integration test, 그리고 더 적은 E2E test를 작성하는 것을 강조합니다.",
      "e2e": "E2E (10%)",
      "integration": "Integration (30%)",
      "unit": "Unit (60%)",
      "whyPyramid": {
        "title": "Why This Pyramid?",
        "unitTests": "Unit Tests: 빠르고, 저렴하며, 작성하기 쉽습니다. 순수 함수와 격리된 컴포넌트 테스트에 완벽합니다.",
        "integrationTests": "Integration Tests: 여러 모듈이 함께 작동하는지 검증합니다 (예: API → state → UI).",
        "e2eTests": "E2E Tests: 비용이 많이 들고 느리지만, 실제 시나리오를 포착합니다. 중요한 경로에만 제한적으로 사용하세요."
      }
    },
    "unitTesting": {
      "title": "Unit Testing",
      "description": "Unit test는 단일 함수나 컴포넌트를 격리하여 테스트합니다. 가장 빠르고 저렴한 형태의 테스팅입니다.",
      "bestTargets": "최적의 Unit Test 대상:",
      "targetList": {
        "pureFunctions": "순수 함수 (유틸리티, 헬퍼, 계산)",
        "components": "최소한의 의존성을 가진 React 컴포넌트",
        "hooks": "간단한 로직을 가진 커스텀 훅"
      }
    },
    "integrationTesting": {
      "title": "Integration Testing",
      "description": "Integration test는 여러 컴포넌트와 모듈이 올바르게 함께 작동하는지 검증합니다. 일반적으로 전체 플로우를 테스트합니다: API 호출 → 상태 업데이트 → UI 렌더링.",
      "commonScenario": {
        "title": "일반적인 Integration Test 시나리오",
        "description": "사용자가 버튼 클릭 → 컴포넌트가 API 요청 → MSW가 가로채서 응답 → 컴포넌트가 상태 업데이트 → 새로운 콘텐츠가 화면에 나타남"
      }
    },
    "e2eTesting": {
      "title": "End-to-End (E2E) Testing",
      "description": "E2E 테스트는 실제 브라우저에서 실행되며 사용자 동작을 시뮬레이션합니다. 가장 느리고 비용이 많이 들지만, unit과 integration test가 놓칠 수 있는 문제를 포착합니다.",
      "whenToUse": "E2E 테스트를 사용할 때: 로그인, 체크아웃 또는 중요한 워크플로우와 같은 핵심 사용자 여정. 모든 상호작용을 테스트하지 말고, 해피 패스와 주요 오류 케이스에 집중하세요."
    },
    "testRatio": {
      "title": "Test Ratio in Practice",
      "recommendedDistribution": "권장 테스트 분포:",
      "unitTests": "Unit Tests: 60-70% - 격리된 로직 검증",
      "integrationTests": "Integration Tests: 20-30% - 컴포넌트 상호작용 검증",
      "e2eTests": "E2E Tests: 5-10% - 핵심 사용자 플로우 테스트",
      "conclusion": "이 비율은 빠른 피드백(unit test는 즉시 실행), 합리적인 커버리지(integration test는 실제 문제를 포착), 그리고 중요한 경로에 대한 확신(E2E test는 전체 시스템을 검증)을 보장합니다."
    }
  },
  "unitTesting": {
    "badge": "React Testing Library",
    "title": "Unit Testing with React Testing Library",
    "description": "사용자가 상호작용하는 방식으로 React 컴포넌트 테스트하기.",
    "philosophy": {
      "title": "React Testing Library Philosophy",
      "description": "React Testing Library의 핵심 원칙: \"구현이 아닌 동작을 테스트하세요.\" 이는 컴포넌트가 어떻게 코딩되었는지가 아니라 사용자 관점에서 테스트를 작성하는 것을 의미합니다.",
      "corePhilosophy": {
        "title": "핵심 철학: 사용자 중심 테스팅",
        "dontTestState": "state를 테스트하지 마세요: 사용자는 state를 볼 수 없습니다; 렌더링된 결과물을 봅니다",
        "dontTestImplementation": "구현을 테스트하지 마세요: 컴포넌트가 작동하는 방식은 중요하지 않습니다",
        "testWhatUsersSee": "사용자가 보는 것을 테스트하세요: DOM 요소, 버튼, 텍스트, 접근성에 집중하세요",
        "simulateUserInteractions": "사용자 상호작용을 시뮬레이션하세요: 클릭, 입력, 폼 제출"
      },
      "dontDoThis": "이렇게 하지 마세요:",
      "doThisInstead": "대신 이렇게 하세요:"
    },
    "queries": {
      "title": "Core Queries: getByRole",
      "description": "가장 권장되는 쿼리는 getByRole입니다. 보조 기술이 DOM과 상호작용하는 방식과 일치하기 때문입니다. 또한 시맨틱 HTML을 장려합니다.",
      "commonRoles": "일반적인 Role:"
    },
    "userInteractions": {
      "title": "User Interactions",
      "description": "사용자 상호작용을 시뮬레이션하려면 userEvent를 사용하세요 (fireEvent가 아닌). userEvent는 더 현실적이며 실제 사용자가 트리거하는 모든 이벤트를 트리거합니다.",
      "comparison": {
        "title": "userEvent vs fireEvent",
        "userEvent": "userEvent: 실제 사용자 동작을 시뮬레이션합니다 (setup(), click(), type() 등)",
        "fireEvent": "fireEvent: DOM 이벤트를 직접 트리거합니다 (오래된 방식, 덜 현실적)"
      }
    },
    "asyncTesting": {
      "title": "Async Testing Patterns",
      "description": "API 호출과 같은 비동기 작업을 테스트할 때 findBy 또는 waitFor를 사용하세요.",
      "queryPriority": {
        "title": "쿼리 우선순위:",
        "getBy": "getBy*: 찾지 못하면 throw (즉시)",
        "findBy": "findBy*: Promise 반환 (요소를 기다림)",
        "queryBy": "queryBy*: 찾지 못하면 null 반환"
      }
    },
    "formExample": {
      "title": "Example: Testing a Form"
    }
  },
  "integrationTesting": {
    "badge": "MSW + RTL",
    "title": "Integration Testing with MSW",
    "description": "모의 API 응답으로 컴포넌트 상호작용 테스트하기.",
    "whatIsMSW": {
      "title": "What is MSW?",
      "description": "Mock Service Worker (MSW)는 브라우저 수준에서 HTTP 요청을 가로채고 모의 응답을 반환하는 라이브러리입니다. 실제 백엔드에 의존하지 않고 컴포넌트가 API 호출을 처리하는 방식을 테스트하는 데 완벽합니다.",
      "whyMSW": {
        "title": "Why MSW for Integration Tests?",
        "noBackend": "백엔드 의존성 없음: 프론트엔드 로직을 독립적으로 테스트",
        "realistic": "현실적인 시나리오: API 오류, 지연, 엣지 케이스 시뮬레이션",
        "deterministic": "결정론적 테스트: 매번 동일한 응답",
        "fast": "빠른 실행: 네트워크 지연 없음"
      },
      "flow": "플로우: 컴포넌트 → fetch() → MSW 가로채기 → 모의 응답 반환 → 컴포넌트가 UI 업데이트"
    },
    "setup": {
      "title": "Setting Up MSW in Tests",
      "description": "테스트를 위한 MSW 핸들러를 초기화하는 테스트 설정 파일을 만드세요."
    },
    "loadingSuccess": {
      "title": "Testing Loading & Success States",
      "description": "컴포넌트가 로딩, 성공, 오류 상태를 올바르게 처리하는지 확인하는 테스트를 작성하세요."
    },
    "errorScenarios": {
      "title": "Testing Error Scenarios",
      "description": "특정 테스트에서 MSW 핸들러를 재정의하여 API 오류를 시뮬레이션하세요."
    },
    "userInteractions": {
      "title": "Testing User Interactions with API",
      "description": "전체 플로우를 테스트하세요: 사용자 동작 → API 호출 → 상태 업데이트 → UI 변경."
    },
    "delays": {
      "title": "Mocking Request Delays",
      "description": "네트워크 지연을 시뮬레이션하여 로딩 상태와 타임아웃을 테스트하세요."
    },
    "bestPractices": {
      "title": "Best Practices for Integration Tests",
      "guidelines": {
        "title": "Integration Testing Guidelines",
        "happyPath": "해피 패스 테스트: 주요 사용자 플로우가 작동해야 함",
        "errorCases": "오류 케이스 테스트: API 오류, 네트워크 문제, 타임아웃",
        "edgeCases": "엣지 케이스 테스트: 빈 상태, 큰 응답, 느린 네트워크",
        "useMSW": "MSW 사용: fetch를 직접 모킹하지 말고 API를 모킹하세요",
        "dontMockComponents": "컴포넌트를 모킹하지 마세요: 실제 컴포넌트 통합을 테스트하세요"
      }
    }
  },
  "vitest": {
    "badge": "Jest vs Vitest",
    "title": "Jest vs Vitest: Choosing Your Test Runner",
    "description": "차이점 이해하기와 각각을 사용할 때.",
    "jest": {
      "title": "Jest: The Industry Standard",
      "description": "Jest는 JavaScript를 위한 가장 널리 사용되는 테스팅 프레임워크입니다. 테스트 러너, 단언 라이브러리, 모킹 유틸리티, 커버리지 리포팅 등 모든 것을 기본으로 제공합니다.",
      "strengths": {
        "title": "Jest Strengths",
        "mature": "성숙한 생태계: 잘 문서화되어 있고, 많은 Stack Overflow 답변",
        "builtin": "내장 도구: 외부 라이브러리가 필요 없음",
        "familiar": "친숙한 문법: 많은 개발자가 알고 있음"
      },
      "weaknesses": {
        "title": "Jest Weaknesses",
        "slow": "느림: 변환 오버헤드로 때때로 테스트가 느림",
        "complex": "복잡한 구성: 현대적인 도구를 위한 설정이 필요할 수 있음"
      }
    },
    "vitest": {
      "title": "Vitest: The Modern Alternative",
      "description": "Vitest는 Vite를 기반으로 구축된 현대적인 테스팅 프레임워크입니다. Jest 호환 API를 제공하지만 훨씬 더 나은 성능을 제공합니다.",
      "strengths": {
        "title": "Vitest Strengths",
        "fast": "매우 빠름: Vite의 ES 모듈과 즉시 HMR 활용",
        "compatible": "Jest 호환: 동일한 문법, 쉬운 마이그레이션",
        "modern": "현대적인 도구: 현대적인 빌드 도구와 원활하게 작동",
        "watch": "Watch 모드: 지능적이고 빠른 피드백"
      },
      "considerations": {
        "title": "Vitest Considerations",
        "newer": "새로움: 작은 커뮤니티지만 빠르게 성장 중",
        "viteDependent": "Vite 의존: Vite 기반 프로젝트 필요"
      }
    },
    "comparison": {
      "title": "Head-to-Head Comparison",
      "feature": "Feature",
      "jest": "Jest",
      "vitest": "Vitest",
      "performance": "Performance",
      "moderate": "보통",
      "veryFast": "매우 빠름",
      "apiCompatibility": "API Compatibility",
      "full": "전체",
      "jestLike": "Jest-like",
      "setupComplexity": "Setup Complexity",
      "simple": "간단",
      "communitySize": "Community Size",
      "hmrSupport": "HMR Support",
      "no": "아니오",
      "yes": "예"
    },
    "setup": {
      "title": "Setting Up Vitest",
      "description": "Vite로 새 프로젝트를 시작하는 경우 Vitest가 권장됩니다."
    },
    "migration": {
      "title": "Migrating from Jest to Vitest",
      "description": "Vitest가 Jest 호환이므로 마이그레이션은 일반적으로 간단합니다.",
      "checklist": {
        "title": "Migration Checklist",
        "install": "Vitest 설치:",
        "createConfig": "vitest.config.ts 생성: 위의 구성 사용",
        "updatePackage": "package.json 업데이트: 테스트 스크립트를 vitest로 변경",
        "replaceJest": "jest.fn()을 vi.fn()으로 변경: 보통 import만 변경",
        "runTests": "테스트 실행: 대부분 변경 없이 통과해야 함"
      }
    },
    "recommendation": {
      "title": "Recommendation",
      "newProjects": "새 프로젝트의 경우: 이미 Vite를 사용하고 있다면 Vitest를 사용하세요. 더 나은 성능과 빠른 피드백 루프를 얻을 수 있습니다.",
      "existingProjects": "기존 Jest 프로젝트의 경우: 어차피 Vite로 마이그레이션할 계획이 아니라면 Jest를 유지하세요. 작은 프로젝트에는 노력이 가치가 없습니다."
    }
  },
  "e2e": {
    "badge": "Playwright & Cypress",
    "title": "End-to-End (E2E) Testing",
    "description": "실제 브라우저 환경에서 완전한 사용자 여정 테스트하기.",
    "whatIsE2E": {
      "title": "What is E2E Testing?",
      "description": "End-to-End 테스트는 실제 브라우저에서 애플리케이션을 실행하고 실제 사용자 상호작용을 시뮬레이션합니다. 진입점에서 출구까지 완전한 플로우를 테스트하여 unit과 integration test가 놓칠 수 있는 문제를 포착합니다.",
      "useCases": {
        "title": "E2E Testing Use Cases",
        "criticalJourneys": "핵심 사용자 여정: 로그인, 체크아웃, 결제",
        "crossBrowser": "크로스 브라우저 호환성: Chrome, Firefox, Safari에서 앱이 작동하는지 확인",
        "visualRegression": "비주얼 회귀: 의도하지 않은 UI 변경 감지",
        "realWorld": "실제 시나리오: 네트워크 문제, 느린 연결"
      },
      "warning": "중요: E2E Tests는 느립니다",
      "warningDescription": "E2E 테스트는 실제 브라우저 동작에 의존하기 때문에 느리고 불안정합니다. 중요한 경로에만 제한적으로 사용하세요 (테스트 스위트의 5-10%)."
    },
    "playwright": {
      "title": "Playwright: Enterprise-Grade Testing",
      "description": "Playwright는 Microsoft가 만들었으며 현대적인 웹 애플리케이션에 최적화되어 있습니다. 빠르고, 신뢰할 수 있으며, CI 친화적입니다.",
      "strengths": {
        "title": "Playwright Strengths",
        "fast": "빠름: 최적화된 실행과 병렬 테스팅",
        "crossBrowser": "크로스 브라우저: Chromium, Firefox, WebKit 기본 지원",
        "ciFriendly": "CI 친화적: headless 모드에서 잘 작동",
        "dx": "개발자 경험: 디버깅과 테스트 녹화를 위한 훌륭한 UI"
      }
    },
    "cypress": {
      "title": "Cypress: Developer Experience Champion",
      "description": "Cypress는 인터랙티브 인터페이스, 뛰어난 디버깅 도구, 테스트 녹화로 개발자 경험을 우선시합니다.",
      "strengths": {
        "title": "Cypress Strengths",
        "bestDX": "최고의 DX: 시각적 피드백이 있는 인터랙티브 테스트 러너",
        "recording": "녹화: 내장 테스트 녹화",
        "debugging": "디버깅: 시간 여행 디버깅, 콘솔 액세스",
        "dashboard": "대시보드: 클라우드 녹화 및 분석"
      },
      "limitations": {
        "title": "Cypress Limitations",
        "singleBrowser": "단일 브라우저: 제한된 크로스 브라우저 지원",
        "jsOnly": "JavaScript만: 다중 탭이나 모바일 테스트 불가"
      }
    },
    "comparison": {
      "title": "Playwright vs Cypress",
      "feature": "Feature",
      "playwright": "Playwright",
      "cypress": "Cypress",
      "speed": "Speed",
      "veryFast": "매우 빠름",
      "moderate": "보통",
      "browsers": "Browsers",
      "threeBrowsers": "3 (Chromium, FF, WebKit)",
      "oneBrowser": "1 (Chrome-based)",
      "dx": "DX",
      "good": "좋음",
      "excellent": "훌륭함",
      "ciSetup": "CI Setup",
      "easy": "쉬움",
      "learningCurve": "Learning Curve",
      "moderateCurve": "보통",
      "easyCurve": "쉬움"
    },
    "bestPractices": {
      "title": "Best Practices for E2E Tests",
      "guidelines": {
        "title": "E2E Testing Guidelines",
        "criticalPaths": "핵심 사용자 경로 테스트: 로그인, 체크아웃, 핵심 기능",
        "avoidDetails": "세부 사항 테스트 피하기: 모든 버튼과 입력을 테스트하지 마세요",
        "meaningfulWaits": "의미 있는 대기 사용: 임의 지연이 아닌 role로 요소를 기다리세요",
        "keepIsolated": "테스트를 격리하세요: 각 테스트는 독립적이어야 함",
        "testData": "테스트 데이터 주의 사용: 테스트 간 데이터베이스 재설정"
      }
    },
    "ci": {
      "title": "Running E2E Tests in CI",
      "description": "모든 푸시마다 E2E 테스트를 실행하도록 CI/CD 파이프라인을 구성하세요."
    }
  },
  "bestPractices": {
    "badge": "Mocking & Best Practices",
    "title": "Mocking Strategies & Testing Antipatterns",
    "description": "효과적으로 모킹하는 방법과 일반적인 테스팅 함정 피하기.",
    "mockTypes": {
      "title": "Types of Mocks",
      "description": "모킹은 테스팅에 필수적이지만, 너무 많은 모킹은 테스트를 비현실적으로 만들 수 있습니다. 전략적으로 모킹을 사용하세요.",
      "summary": {
        "title": "Mock Types Summary",
        "fn": "vi.fn(): 호출을 추적하기 위한 모의 함수 생성",
        "mock": "vi.mock(): 전체 모듈을 모킹으로 교체",
        "spy": "vi.spyOn(): 교체하지 않고 실제 함수를 스파이",
        "msw": "MSW: 네트워크 수준에서 HTTP 요청 모킹"
      }
    },
    "whenToMock": {
      "title": "When to Mock",
      "doMock": "이것들을 모킹하세요:",
      "doMockList": {
        "apis": "외부 API와 네트워크 요청 (MSW 사용)",
        "slowOps": "느린 작업 (데이터베이스, 파일 시스템, 암호화 함수)",
        "browserApis": "브라우저 API (localStorage, geolocation)",
        "externalDeps": "제어할 수 없는 외부 의존성",
        "sideEffects": "검증하고 싶은 부수 효과 (분석, 로깅)"
      },
      "dontMock": "이것들을 모킹하지 마세요:",
      "dontMockList": {
        "ownCode": "자신의 애플리케이션 코드",
        "businessLogic": "핵심 비즈니스 로직",
        "reactComponents": "테스트 중인 React 컴포넌트",
        "simpleUtils": "날짜 포맷팅과 같은 간단한 유틸리티",
        "unrealistic": "테스트를 비현실적으로 만드는 것들"
      }
    },
    "antipatterns": {
      "title": "Testing Antipatterns to Avoid",
      "description": "테스트를 취약하고 신뢰할 수 없게 만드는 일반적인 실수들.",
      "antipattern1": "ANTIPATTERN 1: Testing implementation details",
      "correct1": "CORRECT: Test what user sees",
      "antipattern2": "ANTIPATTERN 2: Over-mocking",
      "correct2": "CORRECT: Mock external dependencies, test real logic",
      "antipattern3": "ANTIPATTERN 3: Snapshot testing",
      "correct3": "CORRECT: Test specific behavior",
      "antipattern4": "ANTIPATTERN 4: Unnecessary waitFor",
      "correct4": "CORRECT: Use findBy for async operations",
      "antipattern5": "ANTIPATTERN 5: Timing-dependent tests",
      "correct5": "CORRECT: Use async utilities"
    },
    "mockingBestPractices": {
      "title": "Mocking Best Practices",
      "goldenRules": {
        "title": "Golden Rules of Mocking",
        "boundary": "경계에서 모킹: 비즈니스 로직이 아닌 네트워크 호출, 파일 I/O를 모킹",
        "keepSimple": "모킹을 간단하게 유지: 복잡한 모킹은 복잡한 의존성을 나타냄",
        "useMSW": "HTTP에는 MSW 사용: API를 모킹하는 가장 현실적인 방법",
        "testBehavior": "동작 테스트, 구현 아님: 테스트 변경 없이 구현 변경",
        "resetMocks": "테스트 간 모킹 재설정: 테스트 오염 방지"
      }
    },
    "commonScenarios": {
      "title": "Testing Common Scenarios",
      "description": "일반적인 테스팅 상황에 대한 실용적인 예제."
    },
    "testOrganization": {
      "title": "Test Organization & Maintenance",
      "keepMaintainable": {
        "title": "Keeping Tests Maintainable",
        "oneConcept": "테스트당 하나의 개념: 테스트는 하나의 단언 아이디어를 가져야 함",
        "clearNames": "명확한 테스트 이름: 무엇이 테스트되는지 설명",
        "arrangeActAssert": "Arrange-Act-Assert 패턴: 테스트를 명확하게 구성",
        "reusableUtils": "재사용 가능한 테스트 유틸리티: 공통 테스트 설정 추출",
        "runFrequently": "테스트를 자주 실행: 문제를 일찍 포착"
      }
    },
    "strategy": {
      "title": "Testing Strategy Summary",
      "yourStrategy": "당신의 테스팅 전략:",
      "unitTests": "60-70% Unit Tests: 순수 함수와 격리된 컴포넌트 테스트",
      "integrationTests": "20-30% Integration Tests: RTL + MSW로 컴포넌트 상호작용 테스트",
      "e2eTests": "5-10% E2E Tests: 핵심 사용자 여정에 Playwright 사용",
      "mockStrategically": "전략적으로 모킹: 외부 API와 느린 작업만",
      "testBehavior": "동작 테스트: 구현 세부 사항이나 내부가 아님"
    }
  }
}
