{
  "header": {
    "title": "AI 기반 개발 도구와 협업",
    "description": "AI 코드 에이전트, MCP, Skills, Hooks를 활용한 현대적 개발 워크플로우 마스터하기"
  },
  "tabs": {
    "all": "All",
    "ai-agents": "AI 에이전트",
    "mcp": "MCP",
    "skills-hooks": "Skills & Hooks",
    "agent-mode": "에이전트 모드",
    "prompt-engineering": "프롬프트 엔지니어링",
    "workflows": "워크플로우",
    "verification": "검증 & 안전",
    "token-optimization": "토큰 최적화"
  },
  "aiAgents": {
    "badge": "Core",
    "title": "AI 코드 에이전트의 이해",
    "description": "AI 도구에서 자율적 에이전트로의 진화와 주요 도구 비교",
    "evolutionTitle": "AI 도구에서 AI 에이전트로",
    "toolsEra": "AI 도구 (2023-2024)",
    "agentsEra": "AI 에이전트 (2025-2026)",
    "toolsFeatures": {
      "autocomplete": "코드 자동완성",
      "singleFile": "단일 파일 내 제안",
      "manualPrompt": "수동 프롬프트 필요",
      "limitedContext": "제한된 컨텍스트"
    },
    "agentsFeatures": {
      "autonomous": "자율적 태스크 수행",
      "multiFile": "멀티파일 편집",
      "toolIntegration": "외부 도구 연동 (MCP)",
      "selfCorrection": "반복적 자기 개선"
    },
    "toolsComparisonTitle": "주요 AI 개발 도구",
    "tools": [
      {
        "name": "Claude Code",
        "desc": "CLI 기반 완전 자율 에이전트",
        "icon": "bot"
      },
      { "name": "Cursor", "desc": "AI-네이티브 IDE, Composer", "icon": "zap" },
      {
        "name": "GitHub Copilot",
        "desc": "VS Code 통합 에이전트",
        "icon": "git-branch"
      },
      { "name": "Windsurf", "desc": "Cascade 에이전트 IDE", "icon": "brain" },
      { "name": "Cline", "desc": "VS Code 자율 에이전트", "icon": "wrench" },
      { "name": "Aider", "desc": "Git 통합 CLI 도구", "icon": "git-branch" }
    ],
    "capabilitiesTitle": "AI 에이전트의 역량과 한계",
    "aiGoodAt": "AI 에이전트가 잘하는 것",
    "humanRequired": "인간이 해야 하는 것",
    "strengths": [
      "복잡한 리팩토링",
      "마이그레이션 작업",
      "보일러플레이트 생성",
      "디버깅 및 에러 추적",
      "문서화 작업"
    ],
    "humanTasks": [
      "아키텍처 결정",
      "비즈니스 로직 검증",
      "보안 최종 검토",
      "사용자 경험 판단",
      "최종 승인"
    ],
    "importantNote": "중요: AI는 도구입니다",
    "importantNoteDesc": "AI 에이전트는 개발자를 대체하는 것이 아니라, 개발자가 더 높은 수준의 문제에 집중할 수 있게 해주는 증강 도구입니다. 최종 책임은 항상 인간에게 있습니다."
  },
  "mcp": {
    "badge": "Protocol",
    "title": "MCP (Model Context Protocol)",
    "description": "AI 에이전트가 외부 도구와 데이터에 접근하는 표준 프로토콜",
    "whatIsTitle": "MCP란 무엇인가?",
    "conceptTitle": "핵심 개념",
    "conceptDesc": "MCP는 AI 에이전트가 데이터베이스, 브라우저, 외부 API 등에 안전하게 접근할 수 있게 해주는 표준 프로토콜입니다. MCP 서버가 특정 기능을 제공하고, AI 에이전트가 이를 호출합니다.",
    "architectureLabel": "MCP 아키텍처",
    "visualizer": {
      "description": "AI 에이전트가 MCP 서버를 통해 다양한 외부 서비스(데이터베이스, 브라우저, GitHub 등)에 접근합니다."
    },
    "serversTitle": "주요 MCP 서버",
    "servers": [
      {
        "name": "PostgreSQL",
        "desc": "데이터베이스 쿼리 실행",
        "icon": "database",
        "example": "@modelcontextprotocol/server-postgres"
      },
      {
        "name": "Playwright",
        "desc": "브라우저 자동화 및 테스트",
        "icon": "globe",
        "example": "@anthropic/mcp-playwright"
      },
      {
        "name": "GitHub",
        "desc": "이슈, PR, 코멘트 관리",
        "icon": "git-branch",
        "example": "@modelcontextprotocol/server-github"
      },
      {
        "name": "Context7",
        "desc": "최신 문서 검색",
        "icon": "file-search",
        "example": "@context7/mcp-server"
      }
    ],
    "configTitle": "MCP 설정 방법",
    "usageTitle": "MCP 활용 예시",
    "tipsTitle": "활용 팁",
    "tips": {
      "tip1": "프로젝트별로 필요한 MCP 서버만 활성화하세요",
      "tip2": "민감한 데이터에 접근하는 서버는 읽기 전용으로 설정하세요",
      "tip3": "커스텀 MCP 서버로 팀 특화 기능을 추가할 수 있습니다"
    }
  },
  "skillsHooks": {
    "badge": "Automation",
    "title": "Skills와 Hooks",
    "description": "재사용 가능한 워크플로우와 이벤트 기반 자동화",
    "skillsTitle": "Skills: 재사용 워크플로우",
    "skillsInfoTitle": "Skill이란?",
    "skillsInfoDesc": "Skill은 자주 사용하는 복잡한 작업을 정의하고 슬래시 명령어로 재사용할 수 있게 해줍니다. /commit, /review-pr 등이 대표적인 예입니다.",
    "skillExamples": [
      { "name": "/commit", "desc": "변경사항 분석 후 컨벤셔널 커밋" },
      { "name": "/review-pr", "desc": "PR 코드 리뷰 및 개선 제안" },
      { "name": "/component", "desc": "컴포넌트 + 테스트 + 스토리 생성" },
      { "name": "/docs", "desc": "코드 분석 후 문서 자동 생성" }
    ],
    "hooksTitle": "Hooks: 이벤트 기반 자동화",
    "hooksInfoTitle": "Hook이란?",
    "hooksInfoDesc": "Hook은 특정 이벤트(파일 저장, 명령 실행 등) 발생 시 자동으로 실행되는 스크립트입니다. 자동 포맷팅, 린팅, 위험한 명령 차단 등에 활용됩니다.",
    "table": {
      "timing": "실행 시점",
      "usage": "용도"
    },
    "hookTypes": [
      {
        "name": "PreToolUse",
        "timing": "도구 실행 전",
        "usage": "위험한 명령 차단, 로깅"
      },
      {
        "name": "PostToolUse",
        "timing": "도구 실행 후",
        "usage": "자동 포맷팅, 린팅, 테스트"
      },
      {
        "name": "Notification",
        "timing": "응답 대기 시",
        "usage": "슬랙/디스코드 알림"
      },
      {
        "name": "Stop",
        "timing": "에이전트 종료 시",
        "usage": "정리 작업, 리포트"
      }
    ],
    "claudeMdTitle": "CLAUDE.md: 프로젝트 컨텍스트",
    "claudeMdInfoTitle": "CLAUDE.md란?",
    "claudeMdInfoDesc": "CLAUDE.md는 AI 에이전트에게 프로젝트의 기술 스택, 코드 컨벤션, 중요 규칙 등을 알려주는 파일입니다. 프로젝트 루트에 위치합니다."
  },
  "agentMode": {
    "badge": "Advanced",
    "title": "에이전트 모드 실전 활용",
    "description": "Claude Code와 Cursor의 에이전트 모드 마스터하기",
    "basicUsageTitle": "기본 사용법",
    "planModeTitle": "Plan 모드 활용",
    "planModeInfoTitle": "언제 Plan 모드를 사용하나?",
    "planModeInfoDesc": "대규모 리팩토링, 새로운 기능 추가 등 영향 범위가 큰 작업에서 Plan 모드를 사용하면 AI가 먼저 계획을 세우고 사용자 승인 후 실행합니다.",
    "subAgentsTitle": "서브에이전트 활용",
    "subAgents": [
      { "name": "Explore", "desc": "코드베이스 탐색 및 분석" },
      { "name": "Bash", "desc": "명령어 실행, 빌드, 테스트" },
      { "name": "Plan", "desc": "구현 계획 수립" },
      { "name": "Code", "desc": "코드 작성 및 수정" }
    ],
    "cursorTitle": "Cursor Agent Mode",
    "cursorInfoTitle": "Cursor Rules 설정",
    "cursorInfoDesc": "Cursor의 .cursor/rules 파일로 AI의 코드 스타일, 자동 작업, 금지 사항 등을 정의할 수 있습니다.",
    "interviewModeTitle": "Interview Mode",
    "interviewModeInfoTitle": "Interview Mode 소개",
    "interviewModeInfoDesc": "인터뷰 모드는 한 번에 큰 결정을 내리기보다, 질문-확인-수정 루프를 통해 점진적으로 컨텍스트를 정교화하는 방식입니다.",
    "interviewModeTipTitle": "권장 사용 패턴",
    "interviewModeTipDesc": "중요한 변경은 먼저 의도/범위를 명확히 합의하고, 작은 증거 기반으로 수정 포인트를 쪼개 검토하는 방식이 토큰 오염을 줄입니다.",
    "teamsVsSubAgentsTitle": "Teams 사용 시점 판단",
    "teamsVsSubAgentsCompareTitle": "Sub-Agent 병렬 vs Teams 의사결정 병행",
    "teamsVsSubAgentsSimulationTitle": "Teams와 Sub-Agent 흐름을 단계별로 비교해보세요",
    "teamsVsSubAgentsStepLabel": "단계",
    "teamsVsSubAgentsReadyHint": "시작: 다음 단계를 눌러 각 전략이 어떤 상태로 전개되는지 확인하세요.",
    "teamsVsSubAgentsNextStep": "다음 단계",
    "teamsVsSubAgentsReset": "초기화",
    "teamsVsSubAgentsIntro": "동일한 과업이라도 처리 방식에 따라 결과 품질과 협업 비용이 달라집니다.",
    "teamsVsSubAgentsPrompt": "동일 과업: 로그인 회복 시나리오를 설계하고 3개의 개선안을 비교",
    "teamsVsSubAgentsParallelTitle": "Sub-Agent 병렬 실행이 유리한 경우",
    "teamsVsSubAgentsParallelItems": [
      "코드베이스 탐색, 테스트 실행, 성능 측정처럼 독립적인 작업을 동시에 처리할 때",
      "결과를 빠르게 병렬 수집해 최종 합치는 구조가 필요한 경우",
      "실행 트랙이 명확하고 의사결정 포인트가 적은 자동화 작업",
      "예측 가능한 텍스트/패치 결과를 선호하는 팀"
    ],
    "teamsVsSubAgentsTeamsTitle": "Teams의 다중 의사결정이 유리한 경우",
    "teamsVsSubAgentsTeamsItems": [
      "요구사항 변경점이 많고 의사결정이 여러 번 오가는 설계형 작업",
      "기능 우선순위, UX 방향, 위험도 판단을 팀 단위에서 합의해야 할 때",
      "시나리오·리뷰·코드 변경점이 한 번에 이어지는 연속적 의사결정이 필요한 경우",
      "결정 근거를 기록하면서 빠르게 합의가 필요한 중간 규모 작업"
    ],
    "teamsVsSubAgentsParallelToken": "예측 가능한 결과 경로로 토큰 사용량이 안정적",
    "teamsVsSubAgentsTeamsToken": "의사결정 메타 데이터가 추가되어 더 많은 컨텍스트가 필요할 수 있음",
    "teamsTitle": "Claude Code Teams",
    "teamsCompareTitle": "Teams 사용 유무로 보기",
    "teamsDescription": "동일 작업에서 Teams 기능을 켰을 때와 끄고 작업했을 때 결과 형태가 다릅니다.",
    "teamsWithGenerativeTitle": "Teams 사용",
    "teamsWithoutGenerativeTitle": "Teams 미사용",
    "teamsWithGenerativeBadge": "ON",
    "teamsWithoutGenerativeBadge": "OFF",
    "teamsSharedPrompt": "동일 요청(팀 공유 질문)",
    "teamsSharedPromptText": "로그인 플로우에서 실패 케이스를 재현하고 개선안을 시각적으로 정리해줘.",
    "teamsVisualOutputTitle": "공통 시각 흐름",
    "teamsTextOutputTitle": "텍스트 흐름",
    "teamsTokenFlowTitle": "예상 컨텍스트 사용량",
    "teamsWithGenerative": [
      "요구사항이 UI 중심일 때 빠르게 시각적으로 제안 가능",
      "의사결정이 필요한 맥락은 함께 합치기 쉬움",
      "동일 주제의 산출물을 팀원이 빠르게 공유 가능",
      "초기 설계 속도는 빠르나, 출력량이 늘어날 수 있음"
    ],
    "teamsWithoutGenerative": [
      "코드·로그 중심 과제에서는 예측 가능한 출력이 높음",
      "스크립트 자동화/리팩토링 같은 반복 작업에서 제어가 단순함",
      "결과를 텍스트로 정리하면 diff 검토가 단순함",
      "중요 판단 포인트만 선별해 확인하기 쉬움"
    ],
    "teamsWithGenerativeToken": "상대적으로 큼: 산출물 수가 많고 협업 맥락이 더 많이 기록됨",
    "teamsWithoutGenerativeToken": "상대적으로 작음: 텍스트 중심 전달로 출력량 통제"
  },
  "tokenOptimization": {
    "badge": "Economy",
    "title": "토큰 절약과 컨텍스트 최적화",
    "description": "Playwright MCP 의존도를 줄이고, MCP/CDP 차이를 이해해 토큰 낭비를 관리하는 실전 패턴",
    "playwrightMigrationTitle": "Playwright MCP에서 Playwright CLI로 전환",
    "playwrightMigrationInfoTitle": "왜 바꾸나?",
    "playwrightMigrationInfoDesc": "브라우저 테스트는 MCP 레이어를 거치면 토큰 사용이 늘어나는 구간이 생깁니다. CLI와 테스트 코드 중심으로 옮기면 불필요한 설명 로그를 줄이고 재현성을 높일 수 있습니다.",
    "playwrightBefore": "# 1) 기존: .claude/settings.json Playwright MCP 예시\n{\n  \"mcpServers\": {\n    \"playwright\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@anthropic/mcp-playwright\"]\n    }\n  }\n}",
    "playwrightAfter": "# 2) 전환: Playwright CLI + 재현 가능한 테스트 코드\n# 패키지\nbun add -D @playwright/test\n\n# 설치 후 브라우저 바이너리\nbunx playwright install\n\n# 테스트 실행(필요 최소 토큰)\nbunx playwright test e2e/login.spec.ts --reporter=dot",
    "playwrightTip1": "UI 기반 장시간 대화보다 스크립트 중심의 재현 시나리오를 유지하세요.",
    "playwrightTip2": "요청당 Playwright MCP 호출 횟수를 줄이고, 검증은 Playwright CLI로 실행하세요.",
    "playwrightTip3": "screenshot/trace 생성은 실패 시점에서만 남기고 기본 동작에서는 제한하세요.",
    "playwrightTip4": "로그를 1줄 요약 후 상세 로그는 파일로 남겨 후처리하세요.",
    "playwrightTip5": "테스트 실패는 에러 메시지+stack만 전달하고, 전체 DOM dump는 필요 시에만 요청하세요.",
    "playwrightTipTitle": "CLI 전환 체크리스트",
    "mcpVsCdpTitle": "MCP vs CDP 비교로 비용/효율 조절",
    "mcpVsCdpIntroTitle": "언제 어떤 방식이 적합한가",
    "mcpVsCdpIntro": "MCP는 빠른 오케스트레이션에 유리하고, CDP는 브라우저 내부 제어가 중요할 때 정밀도가 높습니다.",
    "dimension": "비교 지표",
    "whenToUse": "권장 상황",
    "mcpVsCdpRows": [
      {
        "dimension": "추상화 수준",
        "mcp": "도구 중심 고수준 API",
        "cdp": "브라우저 이벤트/프로토콜 직접 제어",
        "note": "빠른 초기 자동화는 MCP, 정밀 디버깅은 CDP"
      },
      {
        "dimension": "컨텍스트 비용",
        "mcp": "요청당 지시/설명 텍스트가 큼",
        "cdp": "스크립트+스크린샷 기반으로 최소화 가능",
        "note": "반복 검사/크롤/성능 체크는 CLI/CDP 혼합"
      },
      {
        "dimension": "안정성",
        "mcp": "업데이트에 따라 동작이 변동 가능",
        "cdp": "브라우저 버전에 따라 제어 범위가 다름",
        "note": "중간 계층 없이도 동작 신뢰성은 명시적 버전 락 필요"
      },
      {
        "dimension": "팀 협업",
        "mcp": "요청-응답 공유가 쉬움",
        "cdp": "코드 재사용성이 높음",
        "note": "역할분담형 팀일수록 혼합 전략이 유효"
      }
    ],
    "contextOptimizationTitle": "컨텍스트 최적화 루틴",
    "contextOptimizationInfoTitle": "비용을 줄이는 기본 규칙",
    "contextOptimizationInfoDesc": "요청당 목표를 한 문장으로 고정하고, 장문 로그/출력은 후속 단계에서만 요청하세요.",
    "contextOptimizationCode": "# 1. 요청은 목적-범위-검증만 전달\nclaude \"로그인 E2E 실패 케이스만 재현해줘.\n- 대상: /login\n- 실패 조건: 유효하지 않은 토큰\n- 출력: 실패 원인 3개, 수정 위치 2곳\"\n\n# 2. 상세 증거는 필요할 때만\nclaude \"위 수정안 중 1안만 테스트 로그와 함께 상세 증거 붙여줘\"",
    "contextOptimizationChecklist": [
      "한 번에 처리할 변경 수를 제한하고 1~2개 우선순위만 실행",
      "실패 로그는 요약 후 에러 분류만 전달",
      "중복 질문은 하나의 스레드로 묶어 질문 수를 낮춤",
      "스크린샷/트레이스는 실패 케이스에서만 추가",
      "토큰이 큰 응답은 요약 토글 뒤에 상세 요청"
    ]
  },
  "promptEngineering": {
    "badge": "Skill",
    "title": "프롬프트 엔지니어링 고급",
    "description": "AI 에이전트와 효과적으로 소통하는 방법",
    "goalOrientedTitle": "목표 중심 프롬프트",
    "badExample": "나쁜 예 (단계별 지시)",
    "goodExample": "좋은 예 (목표 중심)",
    "contextTitle": "컨텍스트 참조",
    "contextInfoTitle": "효과적인 컨텍스트 전달",
    "contextInfoDesc": "파일 경로, 패턴 참조(@), 문서 참조 등을 활용하면 AI가 더 정확한 결과를 생성합니다.",
    "constraintsTitle": "제약 조건 명시",
    "iterativeTitle": "반복적 개선 패턴",
    "iterativeInfoTitle": "점진적 구체화",
    "iterativeInfoDesc": "복잡한 작업은 한 번에 완벽하게 요청하기보다, 큰 그림 → 세부 구현 → 엣지 케이스 순으로 점진적으로 구체화하세요."
  },
  "workflows": {
    "badge": "Workflow",
    "title": "실전 워크플로우",
    "description": "기능 개발, 버그 수정, 코드 리뷰의 자동화된 워크플로우",
    "featureDevTitle": "기능 개발 워크플로우",
    "featureDevInfoTitle": "전체 플로우",
    "featureDevInfoDesc": "요구사항 분석 → 설계(Plan) → 구현 → 테스트 → 리뷰 → 커밋의 전체 사이클을 AI와 함께 수행합니다.",
    "bugFixTitle": "버그 수정 워크플로우",
    "codeReviewTitle": "코드 리뷰 워크플로우",
    "automationTips": "자동화 팁",
    "tips": {
      "tip1": "GitHub MCP로 PR 생성과 리뷰를 자동화하세요",
      "tip2": "/commit skill로 컨벤셔널 커밋을 자동 생성하세요",
      "tip3": "CI/CD와 연동하여 배포까지 자동화할 수 있습니다"
    }
  },
  "verification": {
    "badge": "Safety",
    "title": "검증과 안전한 사용",
    "description": "AI 생성 코드의 검증, 권한 관리, 팀 가이드라인",
    "autoVerifyTitle": "자동 검증 설정",
    "autoVerifyInfoTitle": "Hook 기반 자동 검증",
    "autoVerifyInfoDesc": "PostToolUse Hook으로 파일 저장 후 자동으로 타입 검사, 린트, 관련 테스트를 실행할 수 있습니다.",
    "manualCheckTitle": "수동 검증 체크리스트",
    "checklistTitle": "AI 생성 코드 리뷰 체크리스트",
    "checklist": [
      "비즈니스 로직이 요구사항과 일치하는가?",
      "기존 코드 패턴과 일관성이 있는가?",
      "보안 취약점이 없는가? (입력 검증, 인증/인가)",
      "성능 문제가 없는가? (N+1, 메모리 누수)",
      "에러 처리가 적절한가?",
      "테스트가 충분한가?"
    ],
    "permissionsTitle": "권한 관리",
    "teamGuidelinesTitle": "팀 가이드라인",
    "teamGuidelines": {
      "allowed": {
        "title": "허용되는 사용",
        "items": [
          "보일러플레이트 코드 생성",
          "테스트 코드 작성 보조",
          "문서화 작업",
          "코드 리뷰 보조",
          "디버깅 지원"
        ]
      },
      "required": {
        "title": "필수 검증 사항",
        "items": [
          "모든 AI 생성 코드는 수동 리뷰 필수",
          "보안 관련 코드는 시니어 개발자 승인 필요",
          "프로덕션 배포 전 전체 테스트 통과 확인"
        ]
      },
      "prohibited": {
        "title": "금지 사항",
        "items": [
          "민감한 정보를 프롬프트에 포함",
          "AI 생성 코드 무검토 커밋",
          "프로덕션 DB에 직접 MCP 연결"
        ]
      }
    },
    "importantNote": "최종 책임",
    "importantNoteDesc": "AI 에이전트가 아무리 강력해도 최종 책임은 항상 개발자에게 있습니다. 모든 AI 생성 코드는 반드시 검토 후 커밋하세요."
  }
}
