{
  "header": {
    "title": "Programming Paradigms",
    "description": "객체 지향 디자인 패턴과 함수형 프로그래밍으로의 전환을 탐구합니다."
  },
  "tabs": {
    "all": "All",
    "oop": "OOP & SOLID",
    "creation": "Creation",
    "structural": "Structural",
    "behavioral": "Behavioral",
    "fp": "Functional"
  },
  "oop": {
    "badge": "Object-Oriented Programming",
    "title": "OOP & SOLID Principles",
    "description": "객체 지향 프로그래밍의 핵심 개념과 설계 원칙입니다.",
    "coreConcepts": {
      "title": "Core Concepts",
      "encapsulation": {
        "label": "Encapsulation:",
        "description": "데이터와 그것을 다루는 메서드를 하나의 단위로 묶는 것입니다."
      },
      "inheritance": {
        "label": "Inheritance:",
        "description": "새로운 클래스가 기존 클래스로부터 속성과 특성을 파생하는 메커니즘입니다."
      },
      "polymorphism": {
        "label": "Polymorphism:",
        "description": "서로 다른 클래스가 동일한 이름의 함수 호출에 대해 각 클래스에 특화된 방식으로 응답할 수 있는 능력입니다."
      }
    },
    "solidPrinciples": {
      "title": "SOLID Principles",
      "single": "ingle Responsibility Principle: 클래스는 변경해야 할 이유가 단 하나만 있어야 합니다.",
      "open": "pen-Closed Principle: 객체나 엔티티는 확장에는 열려 있지만 수정에는 닫혀 있어야 합니다.",
      "liskov": "iskov Substitution Principle: 슈퍼클래스의 객체는 서브클래스의 객체로 대체 가능해야 합니다.",
      "interface": "nterface Segregation Principle: 클라이언트는 사용하지 않는 인터페이스를 구현하도록 강제되어서는 안 됩니다.",
      "dependency": "ependency Inversion Principle: 구체적인 것이 아닌 추상화에 의존해야 합니다."
    }
  },
  "creation": {
    "badge": "Design Patterns",
    "title": "Creation Patterns",
    "description": "객체 생성 메커니즘에 중점을 둔 패턴입니다.",
    "singleton": {
      "title": "Singleton Pattern",
      "description": "클래스가 하나의 인스턴스만 가지도록 보장하고 그것에 대한 전역 접근점을 제공합니다."
    },
    "factory": {
      "title": "Factory Pattern",
      "method": {
        "title": "Factory Method",
        "description": "객체를 생성하기 위한 인터페이스를 정의하지만, 어떤 클래스를 인스턴스화할지는 서브클래스가 결정하도록 합니다."
      },
      "abstract": {
        "title": "Abstract Factory",
        "description": "관련되거나 의존적인 객체들의 패밀리를 생성하기 위한 인터페이스를 제공합니다."
      }
    },
    "builder": {
      "title": "Builder Pattern",
      "description": "복잡한 객체의 구성을 그 표현으로부터 분리하여, 동일한 구성 프로세스로 다른 표현을 생성할 수 있도록 합니다."
    }
  },
  "structural": {
    "badge": "Design Patterns",
    "title": "Structural Patterns",
    "description": "클래스와 객체가 더 큰 구조를 형성하기 위해 어떻게 구성되는지에 관한 패턴입니다.",
    "decorator": {
      "title": "Decorator Pattern",
      "description": "객체에 동적으로 추가 책임을 부여합니다. 서브클래싱에 대한 유연한 대안입니다.",
      "concept": {
        "title": "Concept",
        "description": "Modern TypeScript & ES: @Decorators.\n\n클래스나 메서드에 `@DecoratorName`으로 주석을 답니다. 내부적으로 이것은 원본 클래스/메서드를 새로운 로직(로깅, 검증 등)으로 \"래핑\"합니다."
      }
    },
    "adapter": {
      "title": "Adapter Pattern",
      "description": "호환되지 않는 인터페이스와 협업합니다 (플러그 어댑터)."
    },
    "proxy": {
      "title": "Proxy Pattern",
      "description": "접근을 제어하기 위한 자리 표시자 (보안, 지연 로딩)."
    },
    "facade": {
      "title": "Facade Pattern",
      "description": "복잡한 서브시스템을 위한 단순화된 인터페이스 (스마트 홈)."
    },
    "bridge": {
      "title": "Bridge Pattern",
      "description": "추상화(리모컨)를 구현(장치)에 연결합니다."
    }
  },
  "behavioral": {
    "badge": "Design Patterns",
    "title": "Behavioral Patterns",
    "description": "알고리즘과 객체 간의 책임 할당에 관한 패턴입니다.",
    "observer": {
      "title": "Observer Pattern",
      "description": "관찰 중인 객체에 발생하는 이벤트에 대해 여러 객체에 알림을 보내는 구독 메커니즘을 정의할 수 있습니다.",
      "note": "Common in JS: Event Listeners, RxJS, Redux (Flux)."
    },
    "strategy": {
      "title": "Strategy Pattern",
      "description": "교환 가능한 알고리즘 (결제 방법)."
    },
    "state": {
      "title": "State",
      "description": "객체가 내부 상태가 변경될 때 그 동작을 변경할 수 있도록 합니다. 객체가 클래스를 변경한 것처럼 보입니다."
    },
    "command": {
      "title": "Command",
      "description": "요청을 요청에 대한 모든 정보를 포함하는 독립적인 객체로 변환합니다."
    },
    "templateMethod": {
      "title": "Template Method",
      "description": "슈퍼클래스에서 알고리즘의 골격을 정의하지만 서브클래스가 특정 단계를 재정의할 수 있도록 합니다."
    }
  },
  "fp": {
    "badge": "Functional Programming",
    "title": "Introduction to FP",
    "description": "함수를 적용하고 구성하여 프로그램을 구축하는 프로그래밍 패러다임입니다.",
    "immutability": {
      "title": "Immutability",
      "description": "데이터는 절대 수정되지 않으며, 대신 변경 사항이 포함된 새 복사본이 생성됩니다. 이는 예측 가능한 상태 변경으로 이어집니다 (Redux 스타일).",
      "coreConcepts": {
        "title": "Core Concepts",
        "pureFunctions": {
          "label": "Pure Functions:",
          "description": "동일한 입력이 주어지면 항상 동일한 출력을 반환하며 부작용이 없습니다."
        },
        "immutability": {
          "label": "Immutability:",
          "description": "공유된 가변 상태를 피합니다."
        },
        "higherOrderFunctions": {
          "label": "Higher-Order Functions:",
          "description": "다른 함수를 인자로 받는 함수입니다."
        }
      }
    },
    "currying": {
      "title": "Currying",
      "description": "여러 인자를 받는 함수를 함수의 시퀀스로 변환합니다."
    },
    "monads": {
      "title": "Monads (Maybe)",
      "description": "안전하게 체이닝 가능한 계산 (Null 처리)."
    }
  }
}
