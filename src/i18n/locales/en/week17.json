{
  "header": {
    "title": "AI-Powered Development Tools",
    "description": "Master modern development workflows with AI code agents, MCP, Skills, and Hooks"
  },
  "tabs": {
    "all": "All",
    "ai-agents": "AI Agents",
    "mcp": "MCP",
    "skills-hooks": "Skills & Hooks",
    "agent-mode": "Agent Mode",
    "prompt-engineering": "Prompt Engineering",
    "workflows": "Workflows",
    "verification": "Verification & Safety",
    "token-optimization": "Token Optimization"
  },
  "aiAgents": {
    "badge": "Core",
    "title": "Understanding AI Code Agents",
    "description": "Evolution from AI tools to autonomous agents and comparison of major tools",
    "evolutionTitle": "From AI Tools to AI Agents",
    "toolsEra": "AI Tools (2023-2024)",
    "agentsEra": "AI Agents (2025-2026)",
    "toolsFeatures": {
      "autocomplete": "Code autocomplete",
      "singleFile": "Single file suggestions",
      "manualPrompt": "Manual prompting required",
      "limitedContext": "Limited context"
    },
    "agentsFeatures": {
      "autonomous": "Autonomous task execution",
      "multiFile": "Multi-file editing",
      "toolIntegration": "External tool integration (MCP)",
      "selfCorrection": "Iterative self-improvement"
    },
    "toolsComparisonTitle": "Major AI Development Tools",
    "tools": [
      { "name": "Claude Code", "desc": "CLI-based fully autonomous agent", "icon": "bot" },
      { "name": "Cursor", "desc": "AI-native IDE with Composer", "icon": "zap" },
      { "name": "GitHub Copilot", "desc": "VS Code integrated agent", "icon": "git-branch" },
      { "name": "Windsurf", "desc": "Cascade agent IDE", "icon": "brain" },
      { "name": "Cline", "desc": "VS Code autonomous agent", "icon": "wrench" },
      { "name": "Aider", "desc": "Git-integrated CLI tool", "icon": "git-branch" }
    ],
    "capabilitiesTitle": "AI Agent Capabilities and Limits",
    "aiGoodAt": "What AI Agents Excel At",
    "humanRequired": "What Humans Must Do",
    "strengths": [
      "Complex refactoring",
      "Migration tasks",
      "Boilerplate generation",
      "Debugging and error tracing",
      "Documentation"
    ],
    "humanTasks": [
      "Architecture decisions",
      "Business logic validation",
      "Security final review",
      "User experience judgment",
      "Final approval"
    ],
    "importantNote": "Important: AI is a Tool",
    "importantNoteDesc": "AI agents don't replace developers—they augment them, allowing focus on higher-level problems. Final responsibility always lies with humans."
  },
  "mcp": {
    "badge": "Protocol",
    "title": "MCP (Model Context Protocol)",
    "description": "Standard protocol for AI agents to access external tools and data",
    "whatIsTitle": "What is MCP?",
    "conceptTitle": "Core Concept",
    "conceptDesc": "MCP is a standard protocol that allows AI agents to safely access databases, browsers, external APIs, and more. MCP servers provide specific capabilities that AI agents can invoke.",
    "architectureLabel": "MCP Architecture",
    "visualizer": {
      "description": "AI agents access various external services (databases, browsers, GitHub, etc.) through MCP servers."
    },
    "serversTitle": "Popular MCP Servers",
    "servers": [
      { "name": "PostgreSQL", "desc": "Execute database queries", "icon": "database", "example": "@modelcontextprotocol/server-postgres" },
      { "name": "Playwright", "desc": "Browser automation and testing", "icon": "globe", "example": "@anthropic/mcp-playwright" },
      { "name": "GitHub", "desc": "Issues, PRs, comments management", "icon": "git-branch", "example": "@modelcontextprotocol/server-github" },
      { "name": "Context7", "desc": "Latest documentation search", "icon": "file-search", "example": "@context7/mcp-server" }
    ],
    "configTitle": "MCP Configuration",
    "usageTitle": "MCP Usage Examples",
    "tipsTitle": "Usage Tips",
    "tips": {
      "tip1": "Only enable MCP servers needed for your project",
      "tip2": "Set read-only mode for servers accessing sensitive data",
      "tip3": "Add team-specific features with custom MCP servers"
    }
  },
  "skillsHooks": {
    "badge": "Automation",
    "title": "Skills and Hooks",
    "description": "Reusable workflows and event-driven automation",
    "skillsTitle": "Skills: Reusable Workflows",
    "skillsInfoTitle": "What are Skills?",
    "skillsInfoDesc": "Skills let you define complex, frequently-used tasks and invoke them with slash commands. /commit and /review-pr are typical examples.",
    "skillExamples": [
      { "name": "/commit", "desc": "Analyze changes and create conventional commit" },
      { "name": "/review-pr", "desc": "PR code review with suggestions" },
      { "name": "/component", "desc": "Generate component + test + story" },
      { "name": "/docs", "desc": "Auto-generate docs from code" }
    ],
    "hooksTitle": "Hooks: Event-Driven Automation",
    "hooksInfoTitle": "What are Hooks?",
    "hooksInfoDesc": "Hooks are scripts that run automatically on specific events (file save, command execution, etc.). Used for auto-formatting, linting, blocking dangerous commands, and more.",
    "table": {
      "timing": "Trigger Time",
      "usage": "Use Case"
    },
    "hookTypes": [
      { "name": "PreToolUse", "timing": "Before tool execution", "usage": "Block dangerous commands, logging" },
      { "name": "PostToolUse", "timing": "After tool execution", "usage": "Auto-formatting, linting, testing" },
      { "name": "Notification", "timing": "Waiting for response", "usage": "Slack/Discord notifications" },
      { "name": "Stop", "timing": "Agent termination", "usage": "Cleanup, reporting" }
    ],
    "claudeMdTitle": "CLAUDE.md: Project Context",
    "claudeMdInfoTitle": "What is CLAUDE.md?",
    "claudeMdInfoDesc": "CLAUDE.md informs AI agents about your project's tech stack, coding conventions, and important rules. It lives at the project root."
  },
  "agentMode": {
    "badge": "Advanced",
    "title": "Agent Mode in Practice",
    "description": "Master agent modes in Claude Code and Cursor",
    "basicUsageTitle": "Basic Usage",
    "planModeTitle": "Using Plan Mode",
    "planModeInfoTitle": "When to Use Plan Mode?",
    "planModeInfoDesc": "For large-scale refactoring or new features with wide impact, Plan mode lets AI create a plan first and execute only after user approval.",
    "subAgentsTitle": "Using Sub-Agents",
    "subAgents": [
      { "name": "Explore", "desc": "Codebase exploration and analysis" },
      { "name": "Bash", "desc": "Command execution, builds, tests" },
      { "name": "Plan", "desc": "Implementation planning" },
      { "name": "Code", "desc": "Code writing and modification" }
    ],
    "cursorTitle": "Cursor Agent Mode",
    "cursorInfoTitle": "Cursor Rules Configuration",
    "cursorInfoDesc": "Define AI coding style, automatic tasks, and prohibitions in Cursor's .cursor/rules file.",
    "interviewModeTitle": "Interview Mode",
    "interviewModeInfoTitle": "About Interview Mode",
    "interviewModeInfoDesc": "Interview mode helps refine context by iterating through a question-confirm-revision loop instead of forcing one-shot large decisions.",
    "interviewModeTipTitle": "Recommended Pattern",
    "interviewModeTipDesc": "Start with clear goal + scope, then convert large tasks into validated chunks to reduce context drift and unnecessary output.",
    "teamsVsSubAgentsTitle": "Sub-Agent vs Teams decision guide",
    "teamsVsSubAgentsCompareTitle": "Choosing between parallel Sub-Agents and decision-based Teams",
    "teamsVsSubAgentsSimulationTitle": "Compare Sub-Agent and Teams flows step by step",
    "teamsVsSubAgentsStepLabel": "Step",
    "teamsVsSubAgentsReadyHint": "Start by pressing Next step to see each strategy progress.",
    "teamsVsSubAgentsNextStep": "Next step",
    "teamsVsSubAgentsReset": "Reset",
    "teamsVsSubAgentsIntro": "The same task can differ significantly in speed, quality, and context cost depending on the execution strategy.",
    "teamsVsSubAgentsPrompt": "Same task: design fallback login recovery and compare three improvement options.",
    "teamsVsSubAgentsParallelTitle": "Sub-Agents are best for simple parallel execution",
    "teamsVsSubAgentsParallelItems": [
      "Independent tasks like scanning, testing, and benchmarks can be handled at the same time.",
      "Fast consolidation of outputs is the primary goal.",
      "Expected outputs are deterministic and review-friendly.",
      "Frequent short iteration loops are required."
    ],
    "teamsVsSubAgentsTeamsTitle": "Teams is best for multi-step decision work",
    "teamsVsSubAgentsTeamsItems": [
      "Requirements change frequently and design trade-offs need discussion.",
      "Priority, UX, and risk need to be aligned across the team.",
      "Work requires step-by-step scenario-to-implementation judgment.",
      "Decision rationale should be shared as part of the result."
    ],
    "teamsVsSubAgentsParallelToken": "Token use stays stable because outputs are usually deterministic.",
    "teamsVsSubAgentsTeamsToken": "More shared context and rationale can increase token usage.",
    "teamsTitle": "Claude Code Teams",
    "teamsCompareTitle": "Split by Teams enabled or not",
    "teamsDescription": "The same request produces different outputs depending on whether Teams feature is enabled.",
    "teamsWithGenerativeTitle": "Teams enabled",
    "teamsWithoutGenerativeTitle": "Teams disabled",
    "teamsWithGenerativeBadge": "ON",
    "teamsWithoutGenerativeBadge": "OFF",
    "teamsSharedPrompt": "Shared request (team workflow)",
    "teamsSharedPromptText": "Reproduce login flow failure cases and propose improvements.",
    "teamsVisualOutputTitle": "Shared visual flow",
    "teamsTextOutputTitle": "Text workflow output",
    "teamsTokenFlowTitle": "Estimated context usage pattern",
    "teamsWithGenerative": [
      "Faster ideation when tasks are design-oriented",
      "Easy to share a single collaborative workflow with teammates",
      "Good for planning interaction flow and direction",
      "Output can be richer and therefore slightly heavier"
    ],
    "teamsWithoutGenerative": [
      "More predictable for code/refactor automation tasks",
      "Lower token usage in many text-based workflows",
      "Clear diff-oriented review and deterministic output",
      "Better for environments that require concise summaries"
    ],
    "teamsWithGenerativeToken": "Higher: includes richer artifacts such as visual outputs and context notes.",
    "teamsWithoutGenerativeToken": "Lower: mostly text-based responses reduce verbosity."
  },
  "tokenOptimization": {
    "badge": "Economy",
    "title": "Token Savings and Context Optimization",
    "description": "Practical patterns to reduce token usage by shifting Playwright usage and choosing MCP vs CDP appropriately",
    "playwrightMigrationTitle": "Migrate from Playwright MCP to Playwright CLI",
    "playwrightMigrationInfoTitle": "Why migrate?",
    "playwrightMigrationInfoDesc": "Using MCP wrappers for browser tests adds an extra abstraction layer and can increase prompt context. Using CLI + test scripts improves reproducibility and typically reduces noise in requests.",
    "playwrightBefore": "# 1) Before: Playwright MCP in Claude settings\n{\n  \"mcpServers\": {\n    \"playwright\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@anthropic/mcp-playwright\"]\n    }\n  }\n}",
    "playwrightAfter": "# 2) After: Playwright CLI with focused test script\n# Install packages\nbun add -D @playwright/test\n\n# Install browsers\nbunx playwright install\n\n# Run targeted test (minimal output)\nbunx playwright test e2e/login.spec.ts --reporter=dot",
    "playwrightTip1": "Prioritize script-driven scenarios over long UI-driven chat interactions.",
    "playwrightTip2": "Reduce frequent MCP calls and execute verification through CLI.",
    "playwrightTip3": "Capture screenshots/trace only when failures occur.",
    "playwrightTip4": "Keep logs concise in prompts and save details to files.",
    "playwrightTip5": "For failures, send only error summary and stack; request full DOM only if needed.",
    "playwrightTipTitle": "CLI migration checklist",
    "mcpVsCdpTitle": "Compare MCP and CDP to control cost and precision",
    "mcpVsCdpIntroTitle": "When to choose which",
    "mcpVsCdpIntro": "MCP is fast for orchestration and high-level control; CDP is better when low-level browser detail and determinism are required.",
    "dimension": "Dimension",
    "whenToUse": "Best Use",
    "mcpVsCdpRows": [
      { "dimension": "Abstraction", "mcp": "High-level tool orchestration", "cdp": "Direct browser protocol control", "note": "Use MCP for speed, CDP for precision." },
      { "dimension": "Context cost", "mcp": "More request context in tool-driven commands", "cdp": "Lower if scripts are reused", "note": "Pair repeatable checks with reusable CLI scripts." },
      { "dimension": "Stability", "mcp": "Can change across tool updates", "cdp": "Depends on browser version support", "note": "Pin versions to reduce drift." },
      { "dimension": "Team collaboration", "mcp": "Clearer conversational handoff", "cdp": "Better reproducibility in code reviews", "note": "Use a hybrid approach for mixed teams." }
    ],
    "contextOptimizationTitle": "Context Optimization Playbook",
    "contextOptimizationInfoTitle": "Baseline rules for saving tokens",
    "contextOptimizationInfoDesc": "Keep each request constrained to objective + scope + acceptance criteria, and load full logs only on request.",
    "contextOptimizationCode": "# 1. Keep request strict\nclaude \"Reproduce only login failure in e2e.\n- target: /login\n- failure condition: invalid token\n- output: top 3 causes + 2 patch locations\"\n\n# 2. Ask details only when needed\nclaude \"For the selected fix, provide only failing stack and minimal evidence\"",
    "contextOptimizationChecklist": [
      "Limit each run to 1-2 focused changes",
      "Return concise failure summaries and classification before details",
      "Merge related questions into one thread to reduce back-and-forth",
      "Capture screenshot/trace only for failed scenarios",
      "Defer deep dumps until after an initial pass"
    ]
  },
  "promptEngineering": {
    "badge": "Skill",
    "title": "Advanced Prompt Engineering",
    "description": "Effective communication with AI agents",
    "goalOrientedTitle": "Goal-Oriented Prompts",
    "badExample": "Bad Example (Step-by-step)",
    "goodExample": "Good Example (Goal-oriented)",
    "contextTitle": "Context References",
    "contextInfoTitle": "Effective Context Delivery",
    "contextInfoDesc": "Using file paths, pattern references (@), and doc references helps AI generate more accurate results.",
    "constraintsTitle": "Specifying Constraints",
    "iterativeTitle": "Iterative Improvement Pattern",
    "iterativeInfoTitle": "Gradual Refinement",
    "iterativeInfoDesc": "For complex tasks, don't request perfection at once. Progress from big picture → detailed implementation → edge cases."
  },
  "workflows": {
    "badge": "Workflow",
    "title": "Practical Workflows",
    "description": "Automated workflows for feature development, bug fixes, and code review",
    "featureDevTitle": "Feature Development Workflow",
    "featureDevInfoTitle": "Complete Flow",
    "featureDevInfoDesc": "Execute the full cycle with AI: requirements analysis → design (Plan) → implementation → testing → review → commit.",
    "bugFixTitle": "Bug Fix Workflow",
    "codeReviewTitle": "Code Review Workflow",
    "automationTips": "Automation Tips",
    "tips": {
      "tip1": "Automate PR creation and review with GitHub MCP",
      "tip2": "Auto-generate conventional commits with /commit skill",
      "tip3": "Integrate with CI/CD for deployment automation"
    }
  },
  "verification": {
    "badge": "Safety",
    "title": "Verification and Safe Usage",
    "description": "AI code verification, permission management, and team guidelines",
    "autoVerifyTitle": "Automatic Verification Setup",
    "autoVerifyInfoTitle": "Hook-Based Auto Verification",
    "autoVerifyInfoDesc": "Use PostToolUse hooks to automatically run type checking, linting, and related tests after file saves.",
    "manualCheckTitle": "Manual Verification Checklist",
    "checklistTitle": "AI-Generated Code Review Checklist",
    "checklist": [
      "Does business logic match requirements?",
      "Is it consistent with existing code patterns?",
      "Are there security vulnerabilities? (input validation, auth)",
      "Are there performance issues? (N+1, memory leaks)",
      "Is error handling appropriate?",
      "Is test coverage sufficient?"
    ],
    "permissionsTitle": "Permission Management",
    "teamGuidelinesTitle": "Team Guidelines",
    "teamGuidelines": {
      "allowed": {
        "title": "Allowed Usage",
        "items": [
          "Boilerplate code generation",
          "Test code assistance",
          "Documentation work",
          "Code review assistance",
          "Debugging support"
        ]
      },
      "required": {
        "title": "Required Verification",
        "items": [
          "Manual review required for all AI-generated code",
          "Senior developer approval for security-related code",
          "All tests must pass before production deployment"
        ]
      },
      "prohibited": {
        "title": "Prohibited",
        "items": [
          "Including sensitive information in prompts",
          "Committing AI code without review",
          "Direct MCP connection to production DB"
        ]
      }
    },
    "importantNote": "Final Responsibility",
    "importantNoteDesc": "No matter how powerful AI agents are, final responsibility always lies with developers. Always review AI-generated code before committing."
  }
}
